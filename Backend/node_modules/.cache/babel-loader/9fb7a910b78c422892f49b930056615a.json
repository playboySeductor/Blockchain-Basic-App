{"ast":null,"code":"'use strict';\n\nvar _objectSpread = require(\"C:/Users/SAINIK/Desktop/LEARNING BTC/NFT-Auction-Marketplace/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _regeneratorRuntime = require(\"C:/Users/SAINIK/Desktop/LEARNING BTC/NFT-Auction-Marketplace/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"C:/Users/SAINIK/Desktop/LEARNING BTC/NFT-Auction-Marketplace/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nconst Client = require('../../lib/core');\n\nconst toUrlSearchParams = require('../../lib/to-url-search-params');\n/**\n * @typedef {import('../../lib/core').ClientOptions} ClientOptions\n * @typedef {import('../..').HttpOptions} HttpOptions\n * @typedef {import('ipfs-core-types/src/basic').AbortOptions} AbortOptions\n * @typedef {import('ipfs-core-types/src/pin/remote/service').API} API\n * @typedef {import('ipfs-core-types/src/pin/remote/service').Credentials} Credentials\n * @typedef {import('ipfs-core-types/src/pin/remote/service').RemotePinService} RemotePinService\n * @typedef {import('ipfs-core-types/src/pin/remote/service').RemotePinServiceWithStat} RemotePinServiceWithStat\n * @implements {API}\n */\n\n\nclass Service {\n  /**\n   * @param {ClientOptions} options\n   */\n  constructor(options) {\n    /** @private */\n    this.client = new Client(options);\n  }\n  /**\n   * @param {Client} client\n   * @param {string} name\n   * @param {Credentials & AbortOptions & HttpOptions} options\n   */\n\n\n  static add(client, name, options) {\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n      var endpoint, key, headers, timeout, signal;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            endpoint = options.endpoint, key = options.key, headers = options.headers, timeout = options.timeout, signal = options.signal;\n            _context.next = 3;\n            return client.post('pin/remote/service/add', {\n              timeout,\n              signal,\n              searchParams: toUrlSearchParams({\n                arg: [name, Service.encodeEndpoint(endpoint), key]\n              }),\n              headers\n            });\n\n          case 3:\n          case \"end\":\n            return _context.stop();\n        }\n      }, _callee);\n    }))();\n  }\n  /**\n   * @param {URL} url\n   */\n\n\n  static encodeEndpoint(url) {\n    const href = String(url);\n\n    if (href === 'undefined') {\n      throw Error('endpoint is required');\n    } // Workaround trailing `/` issue in go-ipfs\n    // @see https://github.com/ipfs/go-ipfs/issues/7826\n\n\n    return href[href.length - 1] === '/' ? href.slice(0, -1) : href;\n  }\n  /**\n   * @param {Client} client\n   * @param {string} name\n   * @param {AbortOptions & HttpOptions} [options]\n   */\n\n\n  static rm(client, name, {\n    timeout,\n    signal,\n    headers\n  } = {}) {\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.next = 2;\n            return client.post('pin/remote/service/rm', {\n              timeout,\n              signal,\n              headers,\n              searchParams: toUrlSearchParams({\n                arg: name\n              })\n            });\n\n          case 2:\n          case \"end\":\n            return _context2.stop();\n        }\n      }, _callee2);\n    }))();\n  }\n  /**\n   * @template {true} Stat\n   * @param {Client} client\n   * @param {{ stat?: Stat } & AbortOptions & HttpOptions} [options]\n   */\n\n\n  static ls(client, {\n    stat,\n    timeout,\n    signal,\n    headers\n  } = {}) {\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n      var response, _yield$response$json, RemoteServices;\n\n      return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n        while (1) switch (_context3.prev = _context3.next) {\n          case 0:\n            _context3.next = 2;\n            return client.post('pin/remote/service/ls', {\n              searchParams: stat === true ? toUrlSearchParams({\n                stat\n              }) : undefined,\n              timeout,\n              signal,\n              headers\n            });\n\n          case 2:\n            response = _context3.sent;\n            _context3.next = 5;\n            return response.json();\n\n          case 5:\n            _yield$response$json = _context3.sent;\n            RemoteServices = _yield$response$json.RemoteServices;\n            return _context3.abrupt(\"return\", RemoteServices.map(Service.decodeRemoteService));\n\n          case 8:\n          case \"end\":\n            return _context3.stop();\n        }\n      }, _callee3);\n    }))();\n  }\n  /**\n   * @param {Object} json\n   * @returns {RemotePinServiceWithStat}\n   */\n\n\n  static decodeRemoteService(json) {\n    return _objectSpread({\n      service: json.Service,\n      endpoint: new URL(json.ApiEndpoint)\n    }, json.Stat && {\n      stat: Service.decodeStat(json.Stat)\n    });\n  }\n  /**\n   * @param {Object} json\n   * @returns {import('ipfs-core-types/src/pin/remote/service').Stat}\n   */\n\n\n  static decodeStat(json) {\n    switch (json.Status) {\n      case 'valid':\n        {\n          const _json$PinCount = json.PinCount,\n                Pinning = _json$PinCount.Pinning,\n                Pinned = _json$PinCount.Pinned,\n                Queued = _json$PinCount.Queued,\n                Failed = _json$PinCount.Failed;\n          return {\n            status: 'valid',\n            pinCount: {\n              queued: Queued,\n              pinning: Pinning,\n              pinned: Pinned,\n              failed: Failed\n            }\n          };\n        }\n\n      case 'invalid':\n        {\n          return {\n            status: 'invalid'\n          };\n        }\n\n      default:\n        {\n          return {\n            status: json.Status\n          };\n        }\n    }\n  }\n  /**\n   * Registers remote pinning service with a given name. Errors if service\n   * with the given name is already registered.\n   *\n   * @param {string} name\n   * @param {Credentials & AbortOptions & HttpOptions} options\n   */\n\n\n  add(name, options) {\n    return Service.add(this.client, name, options);\n  }\n  /**\n   * Unregisteres remote pinning service with a given name. If service with such\n   * name isn't registerede this is a noop.\n   *\n   * @param {string} name\n   * @param {AbortOptions & HttpOptions} [options]\n   */\n\n\n  rm(name, options) {\n    return Service.rm(this.client, name, options);\n  }\n  /**\n   * List registered remote pinning services.\n   *\n   * @param {{ stat?: true } & AbortOptions & HttpOptions} [options]\n   */\n\n\n  ls(options) {\n    return Service.ls(this.client, options);\n  }\n\n}\n\nmodule.exports = Service;","map":{"version":3,"sources":["C:/Users/SAINIK/Desktop/LEARNING BTC/NFT-Auction-Marketplace/node_modules/ipfs-http-client/src/pin/remote/service.js"],"names":["Client","require","toUrlSearchParams","Service","constructor","options","client","add","name","endpoint","key","headers","timeout","signal","post","searchParams","arg","encodeEndpoint","url","href","String","Error","length","slice","rm","ls","stat","undefined","response","json","RemoteServices","map","decodeRemoteService","service","URL","ApiEndpoint","Stat","decodeStat","Status","PinCount","Pinning","Pinned","Queued","Failed","status","pinCount","queued","pinning","pinned","failed","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst Client = require('../../lib/core')\nconst toUrlSearchParams = require('../../lib/to-url-search-params')\n\n/**\n * @typedef {import('../../lib/core').ClientOptions} ClientOptions\n * @typedef {import('../..').HttpOptions} HttpOptions\n * @typedef {import('ipfs-core-types/src/basic').AbortOptions} AbortOptions\n * @typedef {import('ipfs-core-types/src/pin/remote/service').API} API\n * @typedef {import('ipfs-core-types/src/pin/remote/service').Credentials} Credentials\n * @typedef {import('ipfs-core-types/src/pin/remote/service').RemotePinService} RemotePinService\n * @typedef {import('ipfs-core-types/src/pin/remote/service').RemotePinServiceWithStat} RemotePinServiceWithStat\n * @implements {API}\n */\nclass Service {\n  /**\n   * @param {ClientOptions} options\n   */\n  constructor (options) {\n    /** @private */\n    this.client = new Client(options)\n  }\n\n  /**\n   * @param {Client} client\n   * @param {string} name\n   * @param {Credentials & AbortOptions & HttpOptions} options\n   */\n  static async add (client, name, options) {\n    const { endpoint, key, headers, timeout, signal } = options\n    await client.post('pin/remote/service/add', {\n      timeout,\n      signal,\n      searchParams: toUrlSearchParams({\n        arg: [name, Service.encodeEndpoint(endpoint), key]\n      }),\n      headers\n    })\n  }\n\n  /**\n   * @param {URL} url\n   */\n  static encodeEndpoint (url) {\n    const href = String(url)\n    if (href === 'undefined') {\n      throw Error('endpoint is required')\n    }\n    // Workaround trailing `/` issue in go-ipfs\n    // @see https://github.com/ipfs/go-ipfs/issues/7826\n    return href[href.length - 1] === '/' ? href.slice(0, -1) : href\n  }\n\n  /**\n   * @param {Client} client\n   * @param {string} name\n   * @param {AbortOptions & HttpOptions} [options]\n   */\n  static async rm (client, name, { timeout, signal, headers } = {}) {\n    await client.post('pin/remote/service/rm', {\n      timeout,\n      signal,\n      headers,\n      searchParams: toUrlSearchParams({\n        arg: name\n      })\n    })\n  }\n\n  /**\n   * @template {true} Stat\n   * @param {Client} client\n   * @param {{ stat?: Stat } & AbortOptions & HttpOptions} [options]\n   */\n  static async ls (client, { stat, timeout, signal, headers } = {}) {\n    const response = await client.post('pin/remote/service/ls', {\n      searchParams: stat === true ? toUrlSearchParams({ stat }) : undefined,\n      timeout,\n      signal,\n      headers\n    })\n\n    /** @type {{RemoteServices: Object[]}} */\n    const { RemoteServices } = await response.json()\n\n    /** @type {Stat extends true ? RemotePinServiceWithStat[] : RemotePinService []} */\n    return (RemoteServices.map(Service.decodeRemoteService))\n  }\n\n  /**\n   * @param {Object} json\n   * @returns {RemotePinServiceWithStat}\n   */\n  static decodeRemoteService (json) {\n    return {\n      service: json.Service,\n      endpoint: new URL(json.ApiEndpoint),\n      ...(json.Stat && { stat: Service.decodeStat(json.Stat) })\n    }\n  }\n\n  /**\n   * @param {Object} json\n   * @returns {import('ipfs-core-types/src/pin/remote/service').Stat}\n   */\n  static decodeStat (json) {\n    switch (json.Status) {\n      case 'valid': {\n        const { Pinning, Pinned, Queued, Failed } = json.PinCount\n        return {\n          status: 'valid',\n          pinCount: {\n            queued: Queued,\n            pinning: Pinning,\n            pinned: Pinned,\n            failed: Failed\n          }\n        }\n      }\n      case 'invalid': {\n        return { status: 'invalid' }\n      }\n      default: {\n        return { status: json.Status }\n      }\n    }\n  }\n\n  /**\n   * Registers remote pinning service with a given name. Errors if service\n   * with the given name is already registered.\n   *\n   * @param {string} name\n   * @param {Credentials & AbortOptions & HttpOptions} options\n   */\n  add (name, options) {\n    return Service.add(this.client, name, options)\n  }\n\n  /**\n   * Unregisteres remote pinning service with a given name. If service with such\n   * name isn't registerede this is a noop.\n   *\n   * @param {string} name\n   * @param {AbortOptions & HttpOptions} [options]\n   */\n  rm (name, options) {\n    return Service.rm(this.client, name, options)\n  }\n\n  /**\n   * List registered remote pinning services.\n   *\n   * @param {{ stat?: true } & AbortOptions & HttpOptions} [options]\n   */\n  ls (options) {\n    return Service.ls(this.client, options)\n  }\n}\n\nmodule.exports = Service\n"]},"metadata":{},"sourceType":"script"}