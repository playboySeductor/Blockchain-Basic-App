{"ast":null,"code":"/* eslint-disable no-undef */\n'use strict';\n\nvar _regeneratorRuntime = require(\"C:/Users/SAINIK/Desktop/LEARNING BTC/NFT-Auction-Marketplace/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _objectSpread = require(\"C:/Users/SAINIK/Desktop/LEARNING BTC/NFT-Auction-Marketplace/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _asyncToGenerator = require(\"C:/Users/SAINIK/Desktop/LEARNING BTC/NFT-Auction-Marketplace/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _awaitAsyncGenerator = require(\"C:/Users/SAINIK/Desktop/LEARNING BTC/NFT-Auction-Marketplace/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\");\n\nvar _wrapAsyncGenerator = require(\"C:/Users/SAINIK/Desktop/LEARNING BTC/NFT-Auction-Marketplace/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\");\n\nvar _asyncIterator = require(\"C:/Users/SAINIK/Desktop/LEARNING BTC/NFT-Auction-Marketplace/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncIterator\");\n\nconst _require = require('./http/fetch'),\n      fetch = _require.fetch,\n      Request = _require.Request,\n      Headers = _require.Headers;\n\nconst _require2 = require('./http/error'),\n      TimeoutError = _require2.TimeoutError,\n      HTTPError = _require2.HTTPError;\n\nconst merge = require('merge-options').bind({\n  ignoreUndefined: true\n});\n\nconst _require3 = require('iso-url'),\n      URL = _require3.URL,\n      URLSearchParams = _require3.URLSearchParams;\n\nconst TextDecoder = require('./text-decoder');\n\nconst _require4 = require('native-abort-controller'),\n      AbortController = _require4.AbortController;\n\nconst anySignal = require('any-signal');\n/**\n * @typedef {import('electron-fetch').Response} Response\n * @typedef {import('stream').Readable} NodeReadableStream\n * @typedef {import('stream').Duplex} NodeDuplexStream\n * @typedef {import('./types').HTTPOptions} HTTPOptions\n */\n\n/**\n * @template TResponse\n * @param {Promise<TResponse>} promise\n * @param {number | undefined} ms\n * @param {AbortController} abortController\n * @returns {Promise<TResponse>}\n */\n\n\nconst timeout = (promise, ms, abortController) => {\n  if (ms === undefined) {\n    return promise;\n  }\n\n  const start = Date.now();\n\n  const timedOut = () => {\n    const time = Date.now() - start;\n    return time >= ms;\n  };\n\n  return new Promise((resolve, reject) => {\n    const timeoutID = setTimeout(() => {\n      if (timedOut()) {\n        reject(new TimeoutError());\n        abortController.abort();\n      }\n    }, ms);\n    /**\n     * @param {(value: any) => void } next\n     */\n\n    const after = next => {\n      /**\n       * @param {any} res\n       */\n      const fn = res => {\n        clearTimeout(timeoutID);\n\n        if (timedOut()) {\n          reject(new TimeoutError());\n          return;\n        }\n\n        next(res);\n      };\n\n      return fn;\n    };\n\n    promise.then(after(resolve), after(reject));\n  });\n};\n\nconst defaults = {\n  throwHttpErrors: true,\n  credentials: 'same-origin'\n};\n\nclass HTTP {\n  /**\n   *\n   * @param {HTTPOptions} options\n   */\n  constructor(options = {}) {\n    /** @type {HTTPOptions} */\n    this.opts = merge(defaults, options);\n  }\n  /**\n   * Fetch\n   *\n   * @param {string | Request} resource\n   * @param {HTTPOptions} options\n   * @returns {Promise<Response>}\n   */\n\n\n  fetch(resource, options = {}) {\n    var _this = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n      var opts, headers, url, searchParams, transformSearchParams, json, abortController, signal, response;\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) switch (_context2.prev = _context2.next) {\n          case 0:\n            /** @type {HTTPOptions} */\n            opts = merge(_this.opts, options);\n            headers = new Headers(opts.headers); // validate resource type\n\n            if (!(typeof resource !== 'string' && !(resource instanceof URL || resource instanceof Request))) {\n              _context2.next = 4;\n              break;\n            }\n\n            throw new TypeError('`resource` must be a string, URL, or Request');\n\n          case 4:\n            url = new URL(resource.toString(), opts.base);\n            searchParams = opts.searchParams, transformSearchParams = opts.transformSearchParams, json = opts.json;\n\n            if (searchParams) {\n              if (typeof transformSearchParams === 'function') {\n                // @ts-ignore\n                url.search = transformSearchParams(new URLSearchParams(opts.searchParams));\n              } else {\n                // @ts-ignore\n                url.search = new URLSearchParams(opts.searchParams);\n              }\n            }\n\n            if (json) {\n              opts.body = JSON.stringify(opts.json);\n              headers.set('content-type', 'application/json');\n            }\n\n            abortController = new AbortController(); // @ts-ignore\n\n            signal = anySignal([abortController.signal, opts.signal]);\n            _context2.next = 12;\n            return timeout(fetch(url.toString(), _objectSpread(_objectSpread({}, opts), {}, {\n              signal,\n              timeout: undefined,\n              headers\n            })), opts.timeout, abortController);\n\n          case 12:\n            response = _context2.sent;\n\n            if (!(!response.ok && opts.throwHttpErrors)) {\n              _context2.next = 18;\n              break;\n            }\n\n            if (!opts.handleError) {\n              _context2.next = 17;\n              break;\n            }\n\n            _context2.next = 17;\n            return opts.handleError(response);\n\n          case 17:\n            throw new HTTPError(response);\n\n          case 18:\n            response.iterator = function () {\n              return fromStream(response.body);\n            };\n\n            response.ndjson = /*#__PURE__*/_wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n              var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, chunk;\n\n              return _regeneratorRuntime.wrap(function _callee$(_context) {\n                while (1) switch (_context.prev = _context.next) {\n                  case 0:\n                    _iteratorNormalCompletion = true;\n                    _didIteratorError = false;\n                    _context.prev = 2;\n                    _iterator = _asyncIterator(ndjson(response.iterator()));\n\n                  case 4:\n                    _context.next = 6;\n                    return _awaitAsyncGenerator(_iterator.next());\n\n                  case 6:\n                    _step = _context.sent;\n                    _iteratorNormalCompletion = _step.done;\n                    _context.next = 10;\n                    return _awaitAsyncGenerator(_step.value);\n\n                  case 10:\n                    _value = _context.sent;\n\n                    if (_iteratorNormalCompletion) {\n                      _context.next = 23;\n                      break;\n                    }\n\n                    chunk = _value;\n\n                    if (!options.transform) {\n                      _context.next = 18;\n                      break;\n                    }\n\n                    _context.next = 16;\n                    return options.transform(chunk);\n\n                  case 16:\n                    _context.next = 20;\n                    break;\n\n                  case 18:\n                    _context.next = 20;\n                    return chunk;\n\n                  case 20:\n                    _iteratorNormalCompletion = true;\n                    _context.next = 4;\n                    break;\n\n                  case 23:\n                    _context.next = 29;\n                    break;\n\n                  case 25:\n                    _context.prev = 25;\n                    _context.t0 = _context[\"catch\"](2);\n                    _didIteratorError = true;\n                    _iteratorError = _context.t0;\n\n                  case 29:\n                    _context.prev = 29;\n                    _context.prev = 30;\n\n                    if (!(!_iteratorNormalCompletion && _iterator.return != null)) {\n                      _context.next = 34;\n                      break;\n                    }\n\n                    _context.next = 34;\n                    return _awaitAsyncGenerator(_iterator.return());\n\n                  case 34:\n                    _context.prev = 34;\n\n                    if (!_didIteratorError) {\n                      _context.next = 37;\n                      break;\n                    }\n\n                    throw _iteratorError;\n\n                  case 37:\n                    return _context.finish(34);\n\n                  case 38:\n                    return _context.finish(29);\n\n                  case 39:\n                  case \"end\":\n                    return _context.stop();\n                }\n              }, _callee, null, [[2, 25, 29, 39], [30,, 34, 38]]);\n            }));\n            return _context2.abrupt(\"return\", response);\n\n          case 21:\n          case \"end\":\n            return _context2.stop();\n        }\n      }, _callee2);\n    }))();\n  }\n  /**\n   * @param {string | Request} resource\n   * @param {HTTPOptions} options\n   * @returns {Promise<Response>}\n   */\n\n\n  post(resource, options = {}) {\n    return this.fetch(resource, _objectSpread(_objectSpread({}, options), {}, {\n      method: 'POST'\n    }));\n  }\n  /**\n   * @param {string | Request} resource\n   * @param {HTTPOptions} options\n   * @returns {Promise<Response>}\n   */\n\n\n  get(resource, options = {}) {\n    return this.fetch(resource, _objectSpread(_objectSpread({}, options), {}, {\n      method: 'GET'\n    }));\n  }\n  /**\n   * @param {string | Request} resource\n   * @param {HTTPOptions} options\n   * @returns {Promise<Response>}\n   */\n\n\n  put(resource, options = {}) {\n    return this.fetch(resource, _objectSpread(_objectSpread({}, options), {}, {\n      method: 'PUT'\n    }));\n  }\n  /**\n   * @param {string | Request} resource\n   * @param {HTTPOptions} options\n   * @returns {Promise<Response>}\n   */\n\n\n  delete(resource, options = {}) {\n    return this.fetch(resource, _objectSpread(_objectSpread({}, options), {}, {\n      method: 'DELETE'\n    }));\n  }\n  /**\n   * @param {string | Request} resource\n   * @param {HTTPOptions} options\n   * @returns {Promise<Response>}\n   */\n\n\n  options(resource, options = {}) {\n    return this.fetch(resource, _objectSpread(_objectSpread({}, options), {}, {\n      method: 'OPTIONS'\n    }));\n  }\n\n}\n/**\n * Parses NDJSON chunks from an iterator\n *\n * @param {AsyncIterable<Uint8Array>} source\n * @returns {AsyncIterable<any>}\n */\n\n\nconst ndjson = /*#__PURE__*/function () {\n  var _ref2 = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(source) {\n    var decoder, buf, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, _value2, chunk, lines, i, l;\n\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) switch (_context3.prev = _context3.next) {\n        case 0:\n          decoder = new TextDecoder();\n          buf = '';\n          _iteratorNormalCompletion2 = true;\n          _didIteratorError2 = false;\n          _context3.prev = 4;\n          _iterator2 = _asyncIterator(source);\n\n        case 6:\n          _context3.next = 8;\n          return _awaitAsyncGenerator(_iterator2.next());\n\n        case 8:\n          _step2 = _context3.sent;\n          _iteratorNormalCompletion2 = _step2.done;\n          _context3.next = 12;\n          return _awaitAsyncGenerator(_step2.value);\n\n        case 12:\n          _value2 = _context3.sent;\n\n          if (_iteratorNormalCompletion2) {\n            _context3.next = 30;\n            break;\n          }\n\n          chunk = _value2;\n          buf += decoder.decode(chunk, {\n            stream: true\n          });\n          lines = buf.split(/\\r?\\n/);\n          i = 0;\n\n        case 18:\n          if (!(i < lines.length - 1)) {\n            _context3.next = 26;\n            break;\n          }\n\n          l = lines[i].trim();\n\n          if (!(l.length > 0)) {\n            _context3.next = 23;\n            break;\n          }\n\n          _context3.next = 23;\n          return JSON.parse(l);\n\n        case 23:\n          i++;\n          _context3.next = 18;\n          break;\n\n        case 26:\n          buf = lines[lines.length - 1];\n\n        case 27:\n          _iteratorNormalCompletion2 = true;\n          _context3.next = 6;\n          break;\n\n        case 30:\n          _context3.next = 36;\n          break;\n\n        case 32:\n          _context3.prev = 32;\n          _context3.t0 = _context3[\"catch\"](4);\n          _didIteratorError2 = true;\n          _iteratorError2 = _context3.t0;\n\n        case 36:\n          _context3.prev = 36;\n          _context3.prev = 37;\n\n          if (!(!_iteratorNormalCompletion2 && _iterator2.return != null)) {\n            _context3.next = 41;\n            break;\n          }\n\n          _context3.next = 41;\n          return _awaitAsyncGenerator(_iterator2.return());\n\n        case 41:\n          _context3.prev = 41;\n\n          if (!_didIteratorError2) {\n            _context3.next = 44;\n            break;\n          }\n\n          throw _iteratorError2;\n\n        case 44:\n          return _context3.finish(41);\n\n        case 45:\n          return _context3.finish(36);\n\n        case 46:\n          buf += decoder.decode();\n          buf = buf.trim();\n\n          if (!(buf.length !== 0)) {\n            _context3.next = 51;\n            break;\n          }\n\n          _context3.next = 51;\n          return JSON.parse(buf);\n\n        case 51:\n        case \"end\":\n          return _context3.stop();\n      }\n    }, _callee3, null, [[4, 32, 36, 46], [37,, 41, 45]]);\n  }));\n\n  return function ndjson(_x) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n/**\n * Stream to AsyncIterable\n *\n * @template TChunk\n * @param {ReadableStream<TChunk> | NodeReadableStream | null} source\n * @returns {AsyncIterable<TChunk>}\n */\n\n\nconst fromStream = source => {\n  // Workaround for https://github.com/node-fetch/node-fetch/issues/766\n  if (isNodeReadableStream(source)) {\n    const iter = source[Symbol.asyncIterator]();\n    return {\n      [Symbol.asyncIterator]() {\n        return {\n          next: iter.next.bind(iter),\n\n          return(value) {\n            source.destroy();\n\n            if (typeof iter.return === 'function') {\n              return iter.return();\n            }\n\n            return Promise.resolve({\n              done: true,\n              value\n            });\n          }\n\n        };\n      }\n\n    };\n  }\n\n  if (isWebReadableStream(source)) {\n    const reader = source.getReader();\n    return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n      var _yield$_awaitAsyncGen, done, value;\n\n      return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n        while (1) switch (_context4.prev = _context4.next) {\n          case 0:\n            _context4.prev = 0;\n\n          case 1:\n            if (!true) {\n              _context4.next = 14;\n              break;\n            }\n\n            _context4.next = 4;\n            return _awaitAsyncGenerator(reader.read());\n\n          case 4:\n            _yield$_awaitAsyncGen = _context4.sent;\n            done = _yield$_awaitAsyncGen.done;\n            value = _yield$_awaitAsyncGen.value;\n\n            if (!done) {\n              _context4.next = 9;\n              break;\n            }\n\n            return _context4.abrupt(\"return\");\n\n          case 9:\n            if (!value) {\n              _context4.next = 12;\n              break;\n            }\n\n            _context4.next = 12;\n            return value;\n\n          case 12:\n            _context4.next = 1;\n            break;\n\n          case 14:\n            _context4.prev = 14;\n            reader.releaseLock();\n            return _context4.finish(14);\n\n          case 17:\n          case \"end\":\n            return _context4.stop();\n        }\n      }, _callee4, null, [[0,, 14, 17]]);\n    }))();\n  }\n\n  if (isAsyncIterable(source)) {\n    return source;\n  }\n\n  throw new TypeError('Body can\\'t be converted to AsyncIterable');\n};\n/**\n * Check if it's an AsyncIterable\n *\n * @template {unknown} TChunk\n * @template {any} Other\n * @param {Other|AsyncIterable<TChunk>} value\n * @returns {value is AsyncIterable<TChunk>}\n */\n\n\nconst isAsyncIterable = value => {\n  return typeof value === 'object' && value !== null && typeof\n  /** @type {any} */\n  value[Symbol.asyncIterator] === 'function';\n};\n/**\n * Check for web readable stream\n *\n * @template {unknown} TChunk\n * @template {any} Other\n * @param {Other|ReadableStream<TChunk>} value\n * @returns {value is ReadableStream<TChunk>}\n */\n\n\nconst isWebReadableStream = value => {\n  return value && typeof\n  /** @type {any} */\n  value.getReader === 'function';\n};\n/**\n * @param {any} value\n * @returns {value is NodeReadableStream}\n */\n\n\nconst isNodeReadableStream = value => Object.prototype.hasOwnProperty.call(value, 'readable') && Object.prototype.hasOwnProperty.call(value, 'writable');\n\nHTTP.HTTPError = HTTPError;\nHTTP.TimeoutError = TimeoutError;\nHTTP.streamToAsyncIterator = fromStream;\n/**\n * @param {string | Request} resource\n * @param {HTTPOptions} [options]\n * @returns {Promise<Response>}\n */\n\nHTTP.post = (resource, options) => new HTTP(options).post(resource, options);\n/**\n * @param {string | Request} resource\n * @param {HTTPOptions} [options]\n * @returns {Promise<Response>}\n */\n\n\nHTTP.get = (resource, options) => new HTTP(options).get(resource, options);\n/**\n * @param {string | Request} resource\n * @param {HTTPOptions} [options]\n * @returns {Promise<Response>}\n */\n\n\nHTTP.put = (resource, options) => new HTTP(options).put(resource, options);\n/**\n * @param {string | Request} resource\n * @param {HTTPOptions} [options]\n * @returns {Promise<Response>}\n */\n\n\nHTTP.delete = (resource, options) => new HTTP(options).delete(resource, options);\n/**\n * @param {string | Request} resource\n * @param {HTTPOptions} [options]\n * @returns {Promise<Response>}\n */\n\n\nHTTP.options = (resource, options) => new HTTP(options).options(resource, options);\n\nmodule.exports = HTTP;","map":{"version":3,"sources":["C:/Users/SAINIK/Desktop/LEARNING BTC/NFT-Auction-Marketplace/node_modules/ipfs-utils/src/http.js"],"names":["require","fetch","Request","Headers","TimeoutError","HTTPError","merge","bind","ignoreUndefined","URL","URLSearchParams","TextDecoder","AbortController","anySignal","timeout","promise","ms","abortController","undefined","start","Date","now","timedOut","time","Promise","resolve","reject","timeoutID","setTimeout","abort","after","next","fn","res","clearTimeout","then","defaults","throwHttpErrors","credentials","HTTP","constructor","options","opts","resource","headers","TypeError","url","toString","base","searchParams","transformSearchParams","json","search","body","JSON","stringify","set","signal","response","ok","handleError","iterator","fromStream","ndjson","chunk","transform","post","method","get","put","delete","source","decoder","buf","decode","stream","lines","split","i","length","l","trim","parse","isNodeReadableStream","iter","Symbol","asyncIterator","return","value","destroy","done","isWebReadableStream","reader","getReader","read","releaseLock","isAsyncIterable","Object","prototype","hasOwnProperty","call","streamToAsyncIterator","module","exports"],"mappings":"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","sourcesContent":["/* eslint-disable no-undef */\n'use strict'\n\nconst { fetch, Request, Headers } = require('./http/fetch')\nconst { TimeoutError, HTTPError } = require('./http/error')\nconst merge = require('merge-options').bind({ ignoreUndefined: true })\nconst { URL, URLSearchParams } = require('iso-url')\nconst TextDecoder = require('./text-decoder')\nconst { AbortController } = require('native-abort-controller')\nconst anySignal = require('any-signal')\n\n/**\n * @typedef {import('electron-fetch').Response} Response\n * @typedef {import('stream').Readable} NodeReadableStream\n * @typedef {import('stream').Duplex} NodeDuplexStream\n * @typedef {import('./types').HTTPOptions} HTTPOptions\n */\n\n/**\n * @template TResponse\n * @param {Promise<TResponse>} promise\n * @param {number | undefined} ms\n * @param {AbortController} abortController\n * @returns {Promise<TResponse>}\n */\nconst timeout = (promise, ms, abortController) => {\n  if (ms === undefined) {\n    return promise\n  }\n\n  const start = Date.now()\n\n  const timedOut = () => {\n    const time = Date.now() - start\n\n    return time >= ms\n  }\n\n  return new Promise((resolve, reject) => {\n    const timeoutID = setTimeout(() => {\n      if (timedOut()) {\n        reject(new TimeoutError())\n        abortController.abort()\n      }\n    }, ms)\n\n    /**\n     * @param {(value: any) => void } next\n     */\n    const after = (next) => {\n      /**\n       * @param {any} res\n       */\n      const fn = (res) => {\n        clearTimeout(timeoutID)\n\n        if (timedOut()) {\n          reject(new TimeoutError())\n          return\n        }\n\n        next(res)\n      }\n      return fn\n    }\n\n    promise\n      .then(after(resolve), after(reject))\n  })\n}\n\nconst defaults = {\n  throwHttpErrors: true,\n  credentials: 'same-origin'\n}\n\nclass HTTP {\n  /**\n   *\n   * @param {HTTPOptions} options\n   */\n  constructor (options = {}) {\n    /** @type {HTTPOptions} */\n    this.opts = merge(defaults, options)\n  }\n\n  /**\n   * Fetch\n   *\n   * @param {string | Request} resource\n   * @param {HTTPOptions} options\n   * @returns {Promise<Response>}\n   */\n  async fetch (resource, options = {}) {\n    /** @type {HTTPOptions} */\n    const opts = merge(this.opts, options)\n    const headers = new Headers(opts.headers)\n\n    // validate resource type\n    if (typeof resource !== 'string' && !(resource instanceof URL || resource instanceof Request)) {\n      throw new TypeError('`resource` must be a string, URL, or Request')\n    }\n\n    const url = new URL(resource.toString(), opts.base)\n\n    const {\n      searchParams,\n      transformSearchParams,\n      json\n    } = opts\n\n    if (searchParams) {\n      if (typeof transformSearchParams === 'function') {\n        // @ts-ignore\n        url.search = transformSearchParams(new URLSearchParams(opts.searchParams))\n      } else {\n        // @ts-ignore\n        url.search = new URLSearchParams(opts.searchParams)\n      }\n    }\n\n    if (json) {\n      opts.body = JSON.stringify(opts.json)\n      headers.set('content-type', 'application/json')\n    }\n\n    const abortController = new AbortController()\n    // @ts-ignore\n    const signal = anySignal([abortController.signal, opts.signal])\n\n    const response = await timeout(\n      fetch(\n        url.toString(),\n        {\n          ...opts,\n          signal,\n          timeout: undefined,\n          headers\n        }\n      ),\n      opts.timeout,\n      abortController\n    )\n\n    if (!response.ok && opts.throwHttpErrors) {\n      if (opts.handleError) {\n        await opts.handleError(response)\n      }\n      throw new HTTPError(response)\n    }\n\n    response.iterator = function () {\n      return fromStream(response.body)\n    }\n\n    response.ndjson = async function * () {\n      for await (const chunk of ndjson(response.iterator())) {\n        if (options.transform) {\n          yield options.transform(chunk)\n        } else {\n          yield chunk\n        }\n      }\n    }\n\n    return response\n  }\n\n  /**\n   * @param {string | Request} resource\n   * @param {HTTPOptions} options\n   * @returns {Promise<Response>}\n   */\n  post (resource, options = {}) {\n    return this.fetch(resource, { ...options, method: 'POST' })\n  }\n\n  /**\n   * @param {string | Request} resource\n   * @param {HTTPOptions} options\n   * @returns {Promise<Response>}\n   */\n  get (resource, options = {}) {\n    return this.fetch(resource, { ...options, method: 'GET' })\n  }\n\n  /**\n   * @param {string | Request} resource\n   * @param {HTTPOptions} options\n   * @returns {Promise<Response>}\n   */\n  put (resource, options = {}) {\n    return this.fetch(resource, { ...options, method: 'PUT' })\n  }\n\n  /**\n   * @param {string | Request} resource\n   * @param {HTTPOptions} options\n   * @returns {Promise<Response>}\n   */\n  delete (resource, options = {}) {\n    return this.fetch(resource, { ...options, method: 'DELETE' })\n  }\n\n  /**\n   * @param {string | Request} resource\n   * @param {HTTPOptions} options\n   * @returns {Promise<Response>}\n   */\n  options (resource, options = {}) {\n    return this.fetch(resource, { ...options, method: 'OPTIONS' })\n  }\n}\n\n/**\n * Parses NDJSON chunks from an iterator\n *\n * @param {AsyncIterable<Uint8Array>} source\n * @returns {AsyncIterable<any>}\n */\nconst ndjson = async function * (source) {\n  const decoder = new TextDecoder()\n  let buf = ''\n\n  for await (const chunk of source) {\n    buf += decoder.decode(chunk, { stream: true })\n    const lines = buf.split(/\\r?\\n/)\n\n    for (let i = 0; i < lines.length - 1; i++) {\n      const l = lines[i].trim()\n      if (l.length > 0) {\n        yield JSON.parse(l)\n      }\n    }\n    buf = lines[lines.length - 1]\n  }\n  buf += decoder.decode()\n  buf = buf.trim()\n  if (buf.length !== 0) {\n    yield JSON.parse(buf)\n  }\n}\n\n/**\n * Stream to AsyncIterable\n *\n * @template TChunk\n * @param {ReadableStream<TChunk> | NodeReadableStream | null} source\n * @returns {AsyncIterable<TChunk>}\n */\nconst fromStream = (source) => {\n  // Workaround for https://github.com/node-fetch/node-fetch/issues/766\n  if (isNodeReadableStream(source)) {\n    const iter = source[Symbol.asyncIterator]()\n    return {\n      [Symbol.asyncIterator] () {\n        return {\n          next: iter.next.bind(iter),\n          return (value) {\n            source.destroy()\n            if (typeof iter.return === 'function') {\n              return iter.return()\n            }\n            return Promise.resolve({ done: true, value })\n          }\n        }\n      }\n    }\n  }\n\n  if (isWebReadableStream(source)) {\n    const reader = source.getReader()\n    return (async function * () {\n      try {\n        while (true) {\n          // Read from the stream\n          const { done, value } = await reader.read()\n          // Exit if we're done\n          if (done) return\n          // Else yield the chunk\n          if (value) {\n            yield value\n          }\n        }\n      } finally {\n        reader.releaseLock()\n      }\n    })()\n  }\n\n  if (isAsyncIterable(source)) {\n    return source\n  }\n\n  throw new TypeError('Body can\\'t be converted to AsyncIterable')\n}\n\n/**\n * Check if it's an AsyncIterable\n *\n * @template {unknown} TChunk\n * @template {any} Other\n * @param {Other|AsyncIterable<TChunk>} value\n * @returns {value is AsyncIterable<TChunk>}\n */\nconst isAsyncIterable = (value) => {\n  return typeof value === 'object' &&\n  value !== null &&\n  typeof /** @type {any} */(value)[Symbol.asyncIterator] === 'function'\n}\n\n/**\n * Check for web readable stream\n *\n * @template {unknown} TChunk\n * @template {any} Other\n * @param {Other|ReadableStream<TChunk>} value\n * @returns {value is ReadableStream<TChunk>}\n */\nconst isWebReadableStream = (value) => {\n  return value && typeof /** @type {any} */(value).getReader === 'function'\n}\n\n/**\n * @param {any} value\n * @returns {value is NodeReadableStream}\n */\nconst isNodeReadableStream = (value) =>\n  Object.prototype.hasOwnProperty.call(value, 'readable') &&\n  Object.prototype.hasOwnProperty.call(value, 'writable')\n\nHTTP.HTTPError = HTTPError\nHTTP.TimeoutError = TimeoutError\nHTTP.streamToAsyncIterator = fromStream\n\n/**\n * @param {string | Request} resource\n * @param {HTTPOptions} [options]\n * @returns {Promise<Response>}\n */\nHTTP.post = (resource, options) => new HTTP(options).post(resource, options)\n\n/**\n * @param {string | Request} resource\n * @param {HTTPOptions} [options]\n * @returns {Promise<Response>}\n */\nHTTP.get = (resource, options) => new HTTP(options).get(resource, options)\n\n/**\n * @param {string | Request} resource\n * @param {HTTPOptions} [options]\n * @returns {Promise<Response>}\n */\nHTTP.put = (resource, options) => new HTTP(options).put(resource, options)\n\n/**\n * @param {string | Request} resource\n * @param {HTTPOptions} [options]\n * @returns {Promise<Response>}\n */\nHTTP.delete = (resource, options) => new HTTP(options).delete(resource, options)\n\n/**\n * @param {string | Request} resource\n * @param {HTTPOptions} [options]\n * @returns {Promise<Response>}\n */\nHTTP.options = (resource, options) => new HTTP(options).options(resource, options)\n\nmodule.exports = HTTP\n"]},"metadata":{},"sourceType":"script"}