{"ast":null,"code":"var _regeneratorRuntime = require(\"C:/Users/SAINIK/Desktop/LEARNING BTC/NFT-Auction-Marketplace/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"C:/Users/SAINIK/Desktop/LEARNING BTC/NFT-Auction-Marketplace/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nconst BufferList = require('bl/BufferList');\n\nconst Reader = require('it-reader');\n\nmodule.exports = function LteReader(source) {\n  const reader = Reader(source);\n  let overflow;\n  const lteReader = {\n    [Symbol.asyncIterator]: () => lteReader,\n\n    next(bytes) {\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var value, _yield$reader$next, nextValue, done;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              if (!overflow) {\n                _context.next = 22;\n                break;\n              }\n\n              if (!(bytes == null || overflow.length === bytes)) {\n                _context.next = 6;\n                break;\n              }\n\n              value = overflow;\n              overflow = null;\n              _context.next = 21;\n              break;\n\n            case 6:\n              if (!(overflow.length > bytes)) {\n                _context.next = 11;\n                break;\n              }\n\n              value = overflow.shallowSlice(0, bytes);\n              overflow = overflow.shallowSlice(bytes);\n              _context.next = 21;\n              break;\n\n            case 11:\n              if (!(overflow.length < bytes)) {\n                _context.next = 21;\n                break;\n              }\n\n              _context.next = 14;\n              return reader.next(bytes - overflow.length);\n\n            case 14:\n              _yield$reader$next = _context.sent;\n              nextValue = _yield$reader$next.value;\n              done = _yield$reader$next.done;\n\n              if (!done) {\n                _context.next = 19;\n                break;\n              }\n\n              throw Object.assign(new Error(\"stream ended before \".concat(bytes - overflow.length, \" bytes became available\")), {\n                code: 'ERR_UNDER_READ'\n              });\n\n            case 19:\n              value = new BufferList([overflow, nextValue]);\n              overflow = null;\n\n            case 21:\n              return _context.abrupt(\"return\", {\n                value\n              });\n\n            case 22:\n              return _context.abrupt(\"return\", reader.next(bytes));\n\n            case 23:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee);\n      }))();\n    },\n\n    nextLte(bytes) {\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var _yield$lteReader$next, done, value;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.next = 2;\n              return lteReader.next();\n\n            case 2:\n              _yield$lteReader$next = _context2.sent;\n              done = _yield$lteReader$next.done;\n              value = _yield$lteReader$next.value;\n\n              if (!done) {\n                _context2.next = 7;\n                break;\n              }\n\n              return _context2.abrupt(\"return\", {\n                done\n              });\n\n            case 7:\n              if (!(value.length <= bytes)) {\n                _context2.next = 9;\n                break;\n              }\n\n              return _context2.abrupt(\"return\", {\n                value\n              });\n\n            case 9:\n              value = BufferList.isBufferList(value) ? value : new BufferList(value);\n\n              if (overflow) {\n                overflow.append(value.shallowSlice(bytes));\n              } else {\n                overflow = value.shallowSlice(bytes);\n              }\n\n              return _context2.abrupt(\"return\", {\n                value: value.shallowSlice(0, bytes)\n              });\n\n            case 12:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2);\n      }))();\n    },\n\n    return() {\n      return reader.return();\n    }\n\n  };\n  return lteReader;\n};","map":{"version":3,"sources":["C:/Users/SAINIK/Desktop/LEARNING BTC/NFT-Auction-Marketplace/node_modules/it-tar/lte-reader.js"],"names":["BufferList","require","Reader","module","exports","LteReader","source","reader","overflow","lteReader","Symbol","asyncIterator","next","bytes","length","value","shallowSlice","nextValue","done","Object","assign","Error","code","nextLte","isBufferList","append","return"],"mappings":";;;;AAAA,MAAMA,UAAU,GAAGC,OAAO,CAAC,eAAD,CAA1B;;AACA,MAAMC,MAAM,GAAGD,OAAO,CAAC,WAAD,CAAtB;;AAEAE,MAAM,CAACC,OAAP,GAAiB,SAASC,SAAT,CAAoBC,MAApB,EAA4B;AAC3C,QAAMC,MAAM,GAAGL,MAAM,CAACI,MAAD,CAArB;AACA,MAAIE,QAAJ;AACA,QAAMC,SAAS,GAAG;AAChB,KAACC,MAAM,CAACC,aAAR,GAAwB,MAAMF,SADd;;AAEVG,IAAAA,IAAN,CAAYC,KAAZ,EAAmB;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA,mBACbL,QADa;AAAA;AAAA;AAAA;;AAAA,oBAGXK,KAAK,IAAI,IAAT,IAAiBL,QAAQ,CAACM,MAAT,KAAoBD,KAH1B;AAAA;AAAA;AAAA;;AAIbE,cAAAA,KAAK,GAAGP,QAAR;AACAA,cAAAA,QAAQ,GAAG,IAAX;AALa;AAAA;;AAAA;AAAA,oBAMJA,QAAQ,CAACM,MAAT,GAAkBD,KANd;AAAA;AAAA;AAAA;;AAObE,cAAAA,KAAK,GAAGP,QAAQ,CAACQ,YAAT,CAAsB,CAAtB,EAAyBH,KAAzB,CAAR;AACAL,cAAAA,QAAQ,GAAGA,QAAQ,CAACQ,YAAT,CAAsBH,KAAtB,CAAX;AARa;AAAA;;AAAA;AAAA,oBASJL,QAAQ,CAACM,MAAT,GAAkBD,KATd;AAAA;AAAA;AAAA;;AAAA;AAAA,qBAU4BN,MAAM,CAACK,IAAP,CAAYC,KAAK,GAAGL,QAAQ,CAACM,MAA7B,CAV5B;;AAAA;AAAA;AAUEG,cAAAA,SAVF,sBAULF,KAVK;AAUaG,cAAAA,IAVb,sBAUaA,IAVb;;AAAA,mBAWTA,IAXS;AAAA;AAAA;AAAA;;AAAA,oBAYLC,MAAM,CAACC,MAAP,CACJ,IAAIC,KAAJ,+BAAiCR,KAAK,GAAGL,QAAQ,CAACM,MAAlD,6BADI,EAEJ;AAAEQ,gBAAAA,IAAI,EAAE;AAAR,eAFI,CAZK;;AAAA;AAiBbP,cAAAA,KAAK,GAAG,IAAIf,UAAJ,CAAe,CAACQ,QAAD,EAAWS,SAAX,CAAf,CAAR;AACAT,cAAAA,QAAQ,GAAG,IAAX;;AAlBa;AAAA,+CAoBR;AAAEO,gBAAAA;AAAF,eApBQ;;AAAA;AAAA,+CAsBVR,MAAM,CAACK,IAAP,CAAYC,KAAZ,CAtBU;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAuBlB,KAzBe;;AA0BVU,IAAAA,OAAN,CAAeV,KAAf,EAAsB;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA,qBACQJ,SAAS,CAACG,IAAV,EADR;;AAAA;AAAA;AACdM,cAAAA,IADc,yBACdA,IADc;AACRH,cAAAA,KADQ,yBACRA,KADQ;;AAAA,mBAEhBG,IAFgB;AAAA;AAAA;AAAA;;AAAA,gDAEH;AAAEA,gBAAAA;AAAF,eAFG;;AAAA;AAAA,oBAGhBH,KAAK,CAACD,MAAN,IAAgBD,KAHA;AAAA;AAAA;AAAA;;AAAA,gDAGc;AAAEE,gBAAAA;AAAF,eAHd;;AAAA;AAIpBA,cAAAA,KAAK,GAAGf,UAAU,CAACwB,YAAX,CAAwBT,KAAxB,IAAiCA,KAAjC,GAAyC,IAAIf,UAAJ,CAAee,KAAf,CAAjD;;AACA,kBAAIP,QAAJ,EAAc;AACZA,gBAAAA,QAAQ,CAACiB,MAAT,CAAgBV,KAAK,CAACC,YAAN,CAAmBH,KAAnB,CAAhB;AACD,eAFD,MAEO;AACLL,gBAAAA,QAAQ,GAAGO,KAAK,CAACC,YAAN,CAAmBH,KAAnB,CAAX;AACD;;AATmB,gDAUb;AAAEE,gBAAAA,KAAK,EAAEA,KAAK,CAACC,YAAN,CAAmB,CAAnB,EAAsBH,KAAtB;AAAT,eAVa;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAWrB,KArCe;;AAsChBa,IAAAA,MAAM,GAAI;AACR,aAAOnB,MAAM,CAACmB,MAAP,EAAP;AACD;;AAxCe,GAAlB;AA0CA,SAAOjB,SAAP;AACD,CA9CD","sourcesContent":["const BufferList = require('bl/BufferList')\nconst Reader = require('it-reader')\n\nmodule.exports = function LteReader (source) {\n  const reader = Reader(source)\n  let overflow\n  const lteReader = {\n    [Symbol.asyncIterator]: () => lteReader,\n    async next (bytes) {\n      if (overflow) {\n        let value\n        if (bytes == null || overflow.length === bytes) {\n          value = overflow\n          overflow = null\n        } else if (overflow.length > bytes) {\n          value = overflow.shallowSlice(0, bytes)\n          overflow = overflow.shallowSlice(bytes)\n        } else if (overflow.length < bytes) {\n          const { value: nextValue, done } = await reader.next(bytes - overflow.length)\n          if (done) {\n            throw Object.assign(\n              new Error(`stream ended before ${bytes - overflow.length} bytes became available`),\n              { code: 'ERR_UNDER_READ' }\n            )\n          }\n          value = new BufferList([overflow, nextValue])\n          overflow = null\n        }\n        return { value }\n      }\n      return reader.next(bytes)\n    },\n    async nextLte (bytes) {\n      let { done, value } = await lteReader.next()\n      if (done) return { done }\n      if (value.length <= bytes) return { value }\n      value = BufferList.isBufferList(value) ? value : new BufferList(value)\n      if (overflow) {\n        overflow.append(value.shallowSlice(bytes))\n      } else {\n        overflow = value.shallowSlice(bytes)\n      }\n      return { value: value.shallowSlice(0, bytes) }\n    },\n    return () {\n      return reader.return()\n    }\n  }\n  return lteReader\n}\n"]},"metadata":{},"sourceType":"script"}