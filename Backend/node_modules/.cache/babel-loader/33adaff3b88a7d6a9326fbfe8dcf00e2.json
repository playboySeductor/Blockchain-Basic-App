{"ast":null,"code":"import bs58 from 'bs58';\nexport default class HashHelper {\n  // Return bytes32 hex string from base58 encoded ipfs hash,\n  // stripping leading 2 bytes from 34 byte IPFS hash\n  // Assume IPFS defaults: function:0x12=sha2, size:0x20=256 bits\n  // E.g. \"QmNSUYVKDSvPUnRLKmuxk9diJ6yS96r1TrAXzjTiBcCLAL\" -->\n  // \"0x017dfd85d4f6cb4dcd715a88101f7b1f06cd1e009b2327a0809d01eb9c91f231\"\n  getBytes32FromIpfsHash(ipfsListing) {\n    return \"0x\" + bs58.decode(ipfsListing).slice(2).toString('hex');\n  } // Return base58 encoded ipfs hash from bytes32 hex string,\n  // E.g. \"0x017dfd85d4f6cb4dcd715a88101f7b1f06cd1e009b2327a0809d01eb9c91f231\"\n  // --> \"QmNSUYVKDSvPUnRLKmuxk9diJ6yS96r1TrAXzjTiBcCLAL\"\n\n\n  getIpfsHashFromBytes32(bytes32Hex) {\n    // Add our default ipfs values for first 2 bytes:\n    // function:0x12=sha2, size:0x20=256 bits\n    // and cut off leading \"0x\"\n    const hashHex = \"1220\" + bytes32Hex.slice(2);\n    const hashBytes = Buffer.from(hashHex, 'hex');\n    const hashStr = bs58.encode(hashBytes);\n    return hashStr;\n  }\n\n}","map":{"version":3,"sources":["C:/Users/SAINIK/Desktop/LEARNING BTC/NFT-Auction-Marketplace/src/utils/hashHelper.js"],"names":["bs58","HashHelper","getBytes32FromIpfsHash","ipfsListing","decode","slice","toString","getIpfsHashFromBytes32","bytes32Hex","hashHex","hashBytes","Buffer","from","hashStr","encode"],"mappings":"AAAA,OAAOA,IAAP,MAAiB,MAAjB;AAEA,eAAe,MAAMC,UAAN,CAAgB;AAC3B;AACA;AACA;AACA;AACA;AAEAC,EAAAA,sBAAsB,CAACC,WAAD,EAAc;AAChC,WAAO,OAAKH,IAAI,CAACI,MAAL,CAAYD,WAAZ,EAAyBE,KAAzB,CAA+B,CAA/B,EAAkCC,QAAlC,CAA2C,KAA3C,CAAZ;AACH,GAT0B,CAW3B;AACA;AACA;;;AAEAC,EAAAA,sBAAsB,CAACC,UAAD,EAAa;AAC/B;AACA;AACA;AACA,UAAMC,OAAO,GAAG,SAASD,UAAU,CAACH,KAAX,CAAiB,CAAjB,CAAzB;AACA,UAAMK,SAAS,GAAGC,MAAM,CAACC,IAAP,CAAYH,OAAZ,EAAqB,KAArB,CAAlB;AACA,UAAMI,OAAO,GAAGb,IAAI,CAACc,MAAL,CAAYJ,SAAZ,CAAhB;AACA,WAAOG,OAAP;AACH;;AAvB0B","sourcesContent":["import bs58 from 'bs58'\r\n\r\nexport default class HashHelper{\r\n    // Return bytes32 hex string from base58 encoded ipfs hash,\r\n    // stripping leading 2 bytes from 34 byte IPFS hash\r\n    // Assume IPFS defaults: function:0x12=sha2, size:0x20=256 bits\r\n    // E.g. \"QmNSUYVKDSvPUnRLKmuxk9diJ6yS96r1TrAXzjTiBcCLAL\" -->\r\n    // \"0x017dfd85d4f6cb4dcd715a88101f7b1f06cd1e009b2327a0809d01eb9c91f231\"\r\n\r\n    getBytes32FromIpfsHash(ipfsListing) {\r\n        return \"0x\"+bs58.decode(ipfsListing).slice(2).toString('hex');\r\n    }\r\n    \r\n    // Return base58 encoded ipfs hash from bytes32 hex string,\r\n    // E.g. \"0x017dfd85d4f6cb4dcd715a88101f7b1f06cd1e009b2327a0809d01eb9c91f231\"\r\n    // --> \"QmNSUYVKDSvPUnRLKmuxk9diJ6yS96r1TrAXzjTiBcCLAL\"\r\n    \r\n    getIpfsHashFromBytes32(bytes32Hex) {\r\n        // Add our default ipfs values for first 2 bytes:\r\n        // function:0x12=sha2, size:0x20=256 bits\r\n        // and cut off leading \"0x\"\r\n        const hashHex = \"1220\" + bytes32Hex.slice(2);\r\n        const hashBytes = Buffer.from(hashHex, 'hex');\r\n        const hashStr = bs58.encode(hashBytes);\r\n        return hashStr\r\n    }\r\n}"]},"metadata":{},"sourceType":"module"}