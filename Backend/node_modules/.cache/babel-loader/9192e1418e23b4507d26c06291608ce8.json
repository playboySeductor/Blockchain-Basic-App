{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"C:/Users/SAINIK/Desktop/LEARNING BTC/NFT-Auction-Marketplace/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"C:/Users/SAINIK/Desktop/LEARNING BTC/NFT-Auction-Marketplace/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nconst errcode = require('err-code');\n\nconst multihash = require('multihashes');\n\nconst crypto = require('./crypto');\n\nconst equals = require('uint8arrays/equals');\n/**\n * @typedef {import(\"./types\").Digest} Digest\n * @typedef {import(\"multihashes\").HashName} HashName\n */\n\n/**\n * Hash the given `bytes` using the algorithm specified by `alg`.\n *\n * @param {Uint8Array} bytes - The value to hash.\n * @param {HashName} alg - The algorithm to use eg 'sha1'\n * @param {number} [length] - Optionally trim the result to this length.\n * @returns {Promise<Uint8Array>}\n */\n\n\nfunction Multihashing(_x, _x2, _x3) {\n  return _Multihashing.apply(this, arguments);\n}\n/**\n * Expose multihash itself, to avoid silly double requires.\n */\n\n\nfunction _Multihashing() {\n  _Multihashing = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(bytes, alg, length) {\n    var digest;\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) switch (_context3.prev = _context3.next) {\n        case 0:\n          _context3.next = 2;\n          return Multihashing.digest(bytes, alg, length);\n\n        case 2:\n          digest = _context3.sent;\n          return _context3.abrupt(\"return\", multihash.encode(digest, alg, length));\n\n        case 4:\n        case \"end\":\n          return _context3.stop();\n      }\n    }, _callee3);\n  }));\n  return _Multihashing.apply(this, arguments);\n}\n\nMultihashing.multihash = multihash;\n/**\n * @param {Uint8Array} bytes - The value to hash.\n * @param {HashName} alg - The algorithm to use eg 'sha1'\n * @param {number} [length] - Optionally trim the result to this length.\n * @returns {Promise<Uint8Array>}\n */\n\nMultihashing.digest = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(bytes, alg, length) {\n    var hash, digest;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          hash = Multihashing.createHash(alg);\n          _context.next = 3;\n          return hash(bytes);\n\n        case 3:\n          digest = _context.sent;\n          return _context.abrupt(\"return\", length ? digest.slice(0, length) : digest);\n\n        case 5:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n\n  return function (_x4, _x5, _x6) {\n    return _ref.apply(this, arguments);\n  };\n}();\n/**\n * Creates a function that hashes with the given algorithm\n *\n * @param {HashName} alg - The algorithm to use eg 'sha1'\n * @returns {Digest} - The hash function corresponding to `alg`\n */\n\n\nMultihashing.createHash = function (alg) {\n  if (!alg) {\n    const e = errcode(new Error('hash algorithm must be specified'), 'ERR_HASH_ALGORITHM_NOT_SPECIFIED');\n    throw e;\n  }\n\n  const code = multihash.coerceCode(alg);\n\n  if (!Multihashing.functions[code]) {\n    throw errcode(new Error(\"multihash function '\".concat(alg, \"' not yet supported\")), 'ERR_HASH_ALGORITHM_NOT_SUPPORTED');\n  }\n\n  return Multihashing.functions[code];\n};\n/**\n * Mapping of multihash codes to their hashing functions.\n *\n * @type {Record<number, Digest>}\n */\n// @ts-ignore - most of those functions aren't typed\n\n\nMultihashing.functions = {\n  // identity\n  0x00: crypto.identity,\n  // sha1\n  0x11: crypto.sha1,\n  // sha2-256\n  0x12: crypto.sha2256,\n  // sha2-512\n  0x13: crypto.sha2512,\n  // sha3-512\n  0x14: crypto.sha3512,\n  // sha3-384\n  0x15: crypto.sha3384,\n  // sha3-256\n  0x16: crypto.sha3256,\n  // sha3-224\n  0x17: crypto.sha3224,\n  // shake-128\n  0x18: crypto.shake128,\n  // shake-256\n  0x19: crypto.shake256,\n  // keccak-224\n  0x1A: crypto.keccak224,\n  // keccak-256\n  0x1B: crypto.keccak256,\n  // keccak-384\n  0x1C: crypto.keccak384,\n  // keccak-512\n  0x1D: crypto.keccak512,\n  // murmur3-128\n  0x22: crypto.murmur3128,\n  // murmur3-32\n  0x23: crypto.murmur332,\n  // dbl-sha2-256\n  0x56: crypto.dblSha2256\n}; // add blake functions\n\ncrypto.addBlake(Multihashing.functions);\n/**\n * @param {Uint8Array} bytes\n * @param {Uint8Array} hash\n * @returns {Promise<boolean>}\n */\n\nMultihashing.validate = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(bytes, hash) {\n    var newHash;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          _context2.next = 2;\n          return Multihashing(bytes, multihash.decode(hash).name);\n\n        case 2:\n          newHash = _context2.sent;\n          return _context2.abrupt(\"return\", equals(hash, newHash));\n\n        case 4:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee2);\n  }));\n\n  return function (_x7, _x8) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nmodule.exports = Multihashing;","map":{"version":3,"sources":["C:/Users/SAINIK/Desktop/LEARNING BTC/NFT-Auction-Marketplace/node_modules/multihashing-async/src/index.js"],"names":["errcode","require","multihash","crypto","equals","Multihashing","bytes","alg","length","digest","encode","hash","createHash","slice","e","Error","code","coerceCode","functions","identity","sha1","sha2256","sha2512","sha3512","sha3384","sha3256","sha3224","shake128","shake256","keccak224","keccak256","keccak384","keccak512","murmur3128","murmur332","dblSha2256","addBlake","validate","decode","name","newHash","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst errcode = require('err-code')\nconst multihash = require('multihashes')\nconst crypto = require('./crypto')\nconst equals = require('uint8arrays/equals')\n\n/**\n * @typedef {import(\"./types\").Digest} Digest\n * @typedef {import(\"multihashes\").HashName} HashName\n */\n\n/**\n * Hash the given `bytes` using the algorithm specified by `alg`.\n *\n * @param {Uint8Array} bytes - The value to hash.\n * @param {HashName} alg - The algorithm to use eg 'sha1'\n * @param {number} [length] - Optionally trim the result to this length.\n * @returns {Promise<Uint8Array>}\n */\nasync function Multihashing (bytes, alg, length) {\n  const digest = await Multihashing.digest(bytes, alg, length)\n  return multihash.encode(digest, alg, length)\n}\n\n/**\n * Expose multihash itself, to avoid silly double requires.\n */\nMultihashing.multihash = multihash\n\n/**\n * @param {Uint8Array} bytes - The value to hash.\n * @param {HashName} alg - The algorithm to use eg 'sha1'\n * @param {number} [length] - Optionally trim the result to this length.\n * @returns {Promise<Uint8Array>}\n */\nMultihashing.digest = async (bytes, alg, length) => {\n  const hash = Multihashing.createHash(alg)\n  const digest = await hash(bytes)\n  return length ? digest.slice(0, length) : digest\n}\n\n/**\n * Creates a function that hashes with the given algorithm\n *\n * @param {HashName} alg - The algorithm to use eg 'sha1'\n * @returns {Digest} - The hash function corresponding to `alg`\n */\nMultihashing.createHash = function (alg) {\n  if (!alg) {\n    const e = errcode(new Error('hash algorithm must be specified'), 'ERR_HASH_ALGORITHM_NOT_SPECIFIED')\n    throw e\n  }\n\n  const code = multihash.coerceCode(alg)\n  if (!Multihashing.functions[code]) {\n    throw errcode(new Error(`multihash function '${alg}' not yet supported`), 'ERR_HASH_ALGORITHM_NOT_SUPPORTED')\n  }\n\n  return Multihashing.functions[code]\n}\n\n/**\n * Mapping of multihash codes to their hashing functions.\n *\n * @type {Record<number, Digest>}\n */\n// @ts-ignore - most of those functions aren't typed\nMultihashing.functions = {\n  // identity\n  0x00: crypto.identity,\n  // sha1\n  0x11: crypto.sha1,\n  // sha2-256\n  0x12: crypto.sha2256,\n  // sha2-512\n  0x13: crypto.sha2512,\n  // sha3-512\n  0x14: crypto.sha3512,\n  // sha3-384\n  0x15: crypto.sha3384,\n  // sha3-256\n  0x16: crypto.sha3256,\n  // sha3-224\n  0x17: crypto.sha3224,\n  // shake-128\n  0x18: crypto.shake128,\n  // shake-256\n  0x19: crypto.shake256,\n  // keccak-224\n  0x1A: crypto.keccak224,\n  // keccak-256\n  0x1B: crypto.keccak256,\n  // keccak-384\n  0x1C: crypto.keccak384,\n  // keccak-512\n  0x1D: crypto.keccak512,\n  // murmur3-128\n  0x22: crypto.murmur3128,\n  // murmur3-32\n  0x23: crypto.murmur332,\n  // dbl-sha2-256\n  0x56: crypto.dblSha2256\n}\n\n// add blake functions\ncrypto.addBlake(Multihashing.functions)\n\n/**\n * @param {Uint8Array} bytes\n * @param {Uint8Array} hash\n * @returns {Promise<boolean>}\n */\nMultihashing.validate = async (bytes, hash) => {\n  const newHash = await Multihashing(bytes, multihash.decode(hash).name)\n\n  return equals(hash, newHash)\n}\n\nmodule.exports = Multihashing\n"]},"metadata":{},"sourceType":"script"}