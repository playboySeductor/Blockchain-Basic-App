{"ast":null,"code":"var _regeneratorRuntime = require(\"C:/Users/SAINIK/Desktop/LEARNING BTC/NFT-Auction-Marketplace/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _objectSpread = require(\"C:/Users/SAINIK/Desktop/LEARNING BTC/NFT-Auction-Marketplace/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _asyncToGenerator = require(\"C:/Users/SAINIK/Desktop/LEARNING BTC/NFT-Auction-Marketplace/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _awaitAsyncGenerator = require(\"C:/Users/SAINIK/Desktop/LEARNING BTC/NFT-Auction-Marketplace/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\");\n\nvar _wrapAsyncGenerator = require(\"C:/Users/SAINIK/Desktop/LEARNING BTC/NFT-Auction-Marketplace/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\");\n\nvar _asyncIterator = require(\"C:/Users/SAINIK/Desktop/LEARNING BTC/NFT-Auction-Marketplace/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncIterator\");\n\nconst defer = require('p-defer');\n\nconst Headers = require('./extract-headers');\n\nconst LteReader = require('./lte-reader');\n\nfunction getPadding(size) {\n  size &= 511;\n  return size && 512 - size;\n}\n\nfunction discardPadding(_x, _x2) {\n  return _discardPadding.apply(this, arguments);\n}\n\nfunction _discardPadding() {\n  _discardPadding = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(reader, size) {\n    var overflow;\n    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) switch (_context4.prev = _context4.next) {\n        case 0:\n          overflow = getPadding(size);\n\n          if (!overflow) {\n            _context4.next = 4;\n            break;\n          }\n\n          _context4.next = 4;\n          return reader.next(overflow);\n\n        case 4:\n        case \"end\":\n          return _context4.stop();\n      }\n    }, _callee4);\n  }));\n  return _discardPadding.apply(this, arguments);\n}\n\nmodule.exports = options => {\n  options = options || {};\n  options.highWaterMark = options.highWaterMark || 1024 * 16;\n  return source => _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n    var reader, gnuLongPath, gnuLongLinkPath, paxGlobal, pax, headerBytes, _yield$_awaitAsyncGen, done, value, header, _yield$_awaitAsyncGen2, gnuLongPathBytes, _yield$_awaitAsyncGen3, gnuLongLinkPathBytes, _yield$_awaitAsyncGen4, paxGlobalBytes, _yield$_awaitAsyncGen5, paxBytes, bytesRemaining, bodyConsumed, firstChunk, body, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, _;\n\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) switch (_context3.prev = _context3.next) {\n        case 0:\n          reader = LteReader(source);\n          _context3.prev = 1;\n\n        case 2:\n          if (!true) {\n            _context3.next = 127;\n            break;\n          }\n\n          _context3.prev = 3;\n          _context3.next = 6;\n          return _awaitAsyncGenerator(reader.next(512));\n\n        case 6:\n          _yield$_awaitAsyncGen = _context3.sent;\n          done = _yield$_awaitAsyncGen.done;\n          value = _yield$_awaitAsyncGen.value;\n\n          if (!done) {\n            _context3.next = 11;\n            break;\n          }\n\n          return _context3.abrupt(\"return\");\n\n        case 11:\n          headerBytes = value;\n          _context3.next = 19;\n          break;\n\n        case 14:\n          _context3.prev = 14;\n          _context3.t0 = _context3[\"catch\"](3);\n\n          if (!(_context3.t0.code === 'ERR_UNDER_READ')) {\n            _context3.next = 18;\n            break;\n          }\n\n          return _context3.abrupt(\"return\");\n\n        case 18:\n          throw _context3.t0;\n\n        case 19:\n          header = Headers.decode(headerBytes, options.filenameEncoding);\n\n          if (header) {\n            _context3.next = 22;\n            break;\n          }\n\n          return _context3.abrupt(\"continue\", 2);\n\n        case 22:\n          if (!(header.type === 'gnu-long-path')) {\n            _context3.next = 34;\n            break;\n          }\n\n          _context3.next = 25;\n          return _awaitAsyncGenerator(reader.next(header.size));\n\n        case 25:\n          _yield$_awaitAsyncGen2 = _context3.sent;\n          done = _yield$_awaitAsyncGen2.done;\n          gnuLongPathBytes = _yield$_awaitAsyncGen2.value;\n\n          if (!done) {\n            _context3.next = 30;\n            break;\n          }\n\n          return _context3.abrupt(\"return\");\n\n        case 30:\n          gnuLongPath = Headers.decodeLongPath(gnuLongPathBytes, options.filenameEncoding);\n          _context3.next = 33;\n          return _awaitAsyncGenerator(discardPadding(reader, header.size));\n\n        case 33:\n          return _context3.abrupt(\"continue\", 2);\n\n        case 34:\n          if (!(header.type === 'gnu-long-link-path')) {\n            _context3.next = 46;\n            break;\n          }\n\n          _context3.next = 37;\n          return _awaitAsyncGenerator(reader.next(header.size));\n\n        case 37:\n          _yield$_awaitAsyncGen3 = _context3.sent;\n          done = _yield$_awaitAsyncGen3.done;\n          gnuLongLinkPathBytes = _yield$_awaitAsyncGen3.value;\n\n          if (!done) {\n            _context3.next = 42;\n            break;\n          }\n\n          return _context3.abrupt(\"return\");\n\n        case 42:\n          gnuLongLinkPath = Headers.decodeLongPath(gnuLongLinkPathBytes, options.filenameEncoding);\n          _context3.next = 45;\n          return _awaitAsyncGenerator(discardPadding(reader, header.size));\n\n        case 45:\n          return _context3.abrupt(\"continue\", 2);\n\n        case 46:\n          if (!(header.type === 'pax-global-header')) {\n            _context3.next = 58;\n            break;\n          }\n\n          _context3.next = 49;\n          return _awaitAsyncGenerator(reader.next(header.size));\n\n        case 49:\n          _yield$_awaitAsyncGen4 = _context3.sent;\n          done = _yield$_awaitAsyncGen4.done;\n          paxGlobalBytes = _yield$_awaitAsyncGen4.value;\n\n          if (!done) {\n            _context3.next = 54;\n            break;\n          }\n\n          return _context3.abrupt(\"return\");\n\n        case 54:\n          paxGlobal = Headers.decodePax(paxGlobalBytes, options.filenameEncoding);\n          _context3.next = 57;\n          return _awaitAsyncGenerator(discardPadding(reader, header.size));\n\n        case 57:\n          return _context3.abrupt(\"continue\", 2);\n\n        case 58:\n          if (!(header.type === 'pax-header')) {\n            _context3.next = 71;\n            break;\n          }\n\n          _context3.next = 61;\n          return _awaitAsyncGenerator(reader.next(header.size));\n\n        case 61:\n          _yield$_awaitAsyncGen5 = _context3.sent;\n          done = _yield$_awaitAsyncGen5.done;\n          paxBytes = _yield$_awaitAsyncGen5.value;\n\n          if (!done) {\n            _context3.next = 66;\n            break;\n          }\n\n          return _context3.abrupt(\"return\");\n\n        case 66:\n          pax = Headers.decodePax(paxBytes, options.filenameEncoding);\n          if (paxGlobal) pax = _objectSpread(_objectSpread({}, paxGlobal), pax);\n          _context3.next = 70;\n          return _awaitAsyncGenerator(discardPadding(reader, header.size));\n\n        case 70:\n          return _context3.abrupt(\"continue\", 2);\n\n        case 71:\n          if (gnuLongPath) {\n            header.name = gnuLongPath;\n            gnuLongPath = null;\n          }\n\n          if (gnuLongLinkPath) {\n            header.linkname = gnuLongLinkPath;\n            gnuLongLinkPath = null;\n          }\n\n          if (pax) {\n            if (pax.path) header.name = pax.path;\n            if (pax.linkpath) header.linkname = pax.linkpath;\n            if (pax.size) header.size = parseInt(pax.size, 10);\n            header.pax = pax;\n            pax = null;\n          }\n\n          if (!(!header.size || header.type === 'directory')) {\n            _context3.next = 78;\n            break;\n          }\n\n          _context3.next = 77;\n          return {\n            header,\n            body: _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n              return _regeneratorRuntime.wrap(function _callee$(_context) {\n                while (1) switch (_context.prev = _context.next) {\n                  case 0:\n                  case \"end\":\n                    return _context.stop();\n                }\n              }, _callee);\n            }))()\n          };\n\n        case 77:\n          return _context3.abrupt(\"continue\", 2);\n\n        case 78:\n          bytesRemaining = header.size;\n          bodyConsumed = defer(); // Prefetch the first chunk.\n          // This allows us to stream entries for small files from the tar without\n          // explicitly streaming the body of each.\n\n          _context3.next = 82;\n          return _awaitAsyncGenerator(reader.nextLte(Math.min(bytesRemaining, options.highWaterMark)));\n\n        case 82:\n          firstChunk = _context3.sent;\n          bytesRemaining -= firstChunk.value.length;\n          if (!bytesRemaining) bodyConsumed.resolve();\n          body = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n            var _yield$_awaitAsyncGen6, done, value;\n\n            return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n              while (1) switch (_context2.prev = _context2.next) {\n                case 0:\n                  _context2.prev = 0;\n                  _context2.next = 3;\n                  return firstChunk.value;\n\n                case 3:\n                  if (!bytesRemaining) {\n                    _context2.next = 17;\n                    break;\n                  }\n\n                  _context2.next = 6;\n                  return _awaitAsyncGenerator(reader.nextLte(bytesRemaining));\n\n                case 6:\n                  _yield$_awaitAsyncGen6 = _context2.sent;\n                  done = _yield$_awaitAsyncGen6.done;\n                  value = _yield$_awaitAsyncGen6.value;\n\n                  if (!done) {\n                    _context2.next = 12;\n                    break;\n                  }\n\n                  bytesRemaining = 0;\n                  return _context2.abrupt(\"return\");\n\n                case 12:\n                  bytesRemaining -= value.length;\n                  _context2.next = 15;\n                  return value;\n\n                case 15:\n                  _context2.next = 3;\n                  break;\n\n                case 17:\n                  _context2.prev = 17;\n                  bodyConsumed.resolve();\n                  return _context2.finish(17);\n\n                case 20:\n                case \"end\":\n                  return _context2.stop();\n              }\n            }, _callee2, null, [[0,, 17, 20]]);\n          }))();\n          _context3.next = 88;\n          return {\n            header,\n            body\n          };\n\n        case 88:\n          _context3.next = 90;\n          return _awaitAsyncGenerator(bodyConsumed.promise);\n\n        case 90:\n          if (!bytesRemaining) {\n            _context3.next = 123;\n            break;\n          }\n\n          _iteratorNormalCompletion = true;\n          _didIteratorError = false;\n          _context3.prev = 93;\n          _iterator = _asyncIterator(body);\n\n        case 95:\n          _context3.next = 97;\n          return _awaitAsyncGenerator(_iterator.next());\n\n        case 97:\n          _step = _context3.sent;\n          _iteratorNormalCompletion = _step.done;\n          _context3.next = 101;\n          return _awaitAsyncGenerator(_step.value);\n\n        case 101:\n          _value = _context3.sent;\n\n          if (_iteratorNormalCompletion) {\n            _context3.next = 107;\n            break;\n          }\n\n          _ = _value;\n\n        case 104:\n          _iteratorNormalCompletion = true;\n          _context3.next = 95;\n          break;\n\n        case 107:\n          _context3.next = 113;\n          break;\n\n        case 109:\n          _context3.prev = 109;\n          _context3.t1 = _context3[\"catch\"](93);\n          _didIteratorError = true;\n          _iteratorError = _context3.t1;\n\n        case 113:\n          _context3.prev = 113;\n          _context3.prev = 114;\n\n          if (!(!_iteratorNormalCompletion && _iterator.return != null)) {\n            _context3.next = 118;\n            break;\n          }\n\n          _context3.next = 118;\n          return _awaitAsyncGenerator(_iterator.return());\n\n        case 118:\n          _context3.prev = 118;\n\n          if (!_didIteratorError) {\n            _context3.next = 121;\n            break;\n          }\n\n          throw _iteratorError;\n\n        case 121:\n          return _context3.finish(118);\n\n        case 122:\n          return _context3.finish(113);\n\n        case 123:\n          _context3.next = 125;\n          return _awaitAsyncGenerator(discardPadding(reader, header.size));\n\n        case 125:\n          _context3.next = 2;\n          break;\n\n        case 127:\n          _context3.prev = 127;\n          _context3.next = 130;\n          return _awaitAsyncGenerator(reader.return());\n\n        case 130:\n          return _context3.finish(127);\n\n        case 131:\n        case \"end\":\n          return _context3.stop();\n      }\n    }, _callee3, null, [[1,, 127, 131], [3, 14], [93, 109, 113, 123], [114,, 118, 122]]);\n  }))();\n};","map":{"version":3,"sources":["C:/Users/SAINIK/Desktop/LEARNING BTC/NFT-Auction-Marketplace/node_modules/it-tar/extract.js"],"names":["defer","require","Headers","LteReader","getPadding","size","discardPadding","reader","overflow","next","module","exports","options","highWaterMark","source","done","value","headerBytes","code","header","decode","filenameEncoding","type","gnuLongPathBytes","gnuLongPath","decodeLongPath","gnuLongLinkPathBytes","gnuLongLinkPath","paxGlobalBytes","paxGlobal","decodePax","paxBytes","pax","name","linkname","path","linkpath","parseInt","body","bytesRemaining","bodyConsumed","nextLte","Math","min","firstChunk","length","resolve","promise","_","return"],"mappings":";;;;;;;;;;;;AAAA,MAAMA,KAAK,GAAGC,OAAO,CAAC,SAAD,CAArB;;AACA,MAAMC,OAAO,GAAGD,OAAO,CAAC,mBAAD,CAAvB;;AACA,MAAME,SAAS,GAAGF,OAAO,CAAC,cAAD,CAAzB;;AAEA,SAASG,UAAT,CAAqBC,IAArB,EAA2B;AACzBA,EAAAA,IAAI,IAAI,GAAR;AACA,SAAOA,IAAI,IAAI,MAAMA,IAArB;AACD;;SAEcC,c;;;;;6EAAf,kBAA+BC,MAA/B,EAAuCF,IAAvC;AAAA;AAAA;AAAA;AAAA;AACQG,UAAAA,QADR,GACmBJ,UAAU,CAACC,IAAD,CAD7B;;AAAA,eAEMG,QAFN;AAAA;AAAA;AAAA;;AAAA;AAAA,iBAEsBD,MAAM,CAACE,IAAP,CAAYD,QAAZ,CAFtB;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;;;AAKAE,MAAM,CAACC,OAAP,GAAiBC,OAAO,IAAI;AAC1BA,EAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB;AACAA,EAAAA,OAAO,CAACC,aAAR,GAAwBD,OAAO,CAACC,aAAR,IAAyB,OAAO,EAAxD;AAEA,SAAOC,MAAM,IAAI,2DAAC;AAAA;;AAAA;AAAA;AAAA;AACVP,UAAAA,MADU,GACDJ,SAAS,CAACW,MAAD,CADR;AAAA;;AAAA;AAAA,eAKP,IALO;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA,sCAQoBP,MAAM,CAACE,IAAP,CAAY,GAAZ,CARpB;;AAAA;AAAA;AAQFM,UAAAA,IARE,yBAQFA,IARE;AAQIC,UAAAA,KARJ,yBAQIA,KARJ;;AAAA,eASND,IATM;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAUVE,UAAAA,WAAW,GAAGD,KAAd;AAVU;AAAA;;AAAA;AAAA;AAAA;;AAAA,gBAaN,aAAIE,IAAJ,KAAa,gBAbP;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;;AAAA;AAiBNC,UAAAA,MAjBM,GAiBGjB,OAAO,CAACkB,MAAR,CAAeH,WAAf,EAA4BL,OAAO,CAACS,gBAApC,CAjBH;;AAAA,cAkBPF,MAlBO;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA,gBAoBRA,MAAM,CAACG,IAAP,KAAgB,eApBR;AAAA;AAAA;AAAA;;AAAA;AAAA,sCAqBsCf,MAAM,CAACE,IAAP,CAAYU,MAAM,CAACd,IAAnB,CArBtC;;AAAA;AAAA;AAqBFU,UAAAA,IArBE,0BAqBFA,IArBE;AAqBWQ,UAAAA,gBArBX,0BAqBIP,KArBJ;;AAAA,eAsBND,IAtBM;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAuBVS,UAAAA,WAAW,GAAGtB,OAAO,CAACuB,cAAR,CAAuBF,gBAAvB,EAAyCX,OAAO,CAACS,gBAAjD,CAAd;AAvBU;AAAA,sCAwBJf,cAAc,CAACC,MAAD,EAASY,MAAM,CAACd,IAAhB,CAxBV;;AAAA;AAAA;;AAAA;AAAA,gBA4BRc,MAAM,CAACG,IAAP,KAAgB,oBA5BR;AAAA;AAAA;AAAA;;AAAA;AAAA,sCA6B0Cf,MAAM,CAACE,IAAP,CAAYU,MAAM,CAACd,IAAnB,CA7B1C;;AAAA;AAAA;AA6BFU,UAAAA,IA7BE,0BA6BFA,IA7BE;AA6BWW,UAAAA,oBA7BX,0BA6BIV,KA7BJ;;AAAA,eA8BND,IA9BM;AAAA;AAAA;AAAA;;AAAA;;AAAA;AA+BVY,UAAAA,eAAe,GAAGzB,OAAO,CAACuB,cAAR,CAAuBC,oBAAvB,EAA6Cd,OAAO,CAACS,gBAArD,CAAlB;AA/BU;AAAA,sCAgCJf,cAAc,CAACC,MAAD,EAASY,MAAM,CAACd,IAAhB,CAhCV;;AAAA;AAAA;;AAAA;AAAA,gBAoCRc,MAAM,CAACG,IAAP,KAAgB,mBApCR;AAAA;AAAA;AAAA;;AAAA;AAAA,sCAqCoCf,MAAM,CAACE,IAAP,CAAYU,MAAM,CAACd,IAAnB,CArCpC;;AAAA;AAAA;AAqCFU,UAAAA,IArCE,0BAqCFA,IArCE;AAqCWa,UAAAA,cArCX,0BAqCIZ,KArCJ;;AAAA,eAsCND,IAtCM;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAuCVc,UAAAA,SAAS,GAAG3B,OAAO,CAAC4B,SAAR,CAAkBF,cAAlB,EAAkChB,OAAO,CAACS,gBAA1C,CAAZ;AAvCU;AAAA,sCAwCJf,cAAc,CAACC,MAAD,EAASY,MAAM,CAACd,IAAhB,CAxCV;;AAAA;AAAA;;AAAA;AAAA,gBA4CRc,MAAM,CAACG,IAAP,KAAgB,YA5CR;AAAA;AAAA;AAAA;;AAAA;AAAA,sCA6C8Bf,MAAM,CAACE,IAAP,CAAYU,MAAM,CAACd,IAAnB,CA7C9B;;AAAA;AAAA;AA6CFU,UAAAA,IA7CE,0BA6CFA,IA7CE;AA6CWgB,UAAAA,QA7CX,0BA6CIf,KA7CJ;;AAAA,eA8CND,IA9CM;AAAA;AAAA;AAAA;;AAAA;;AAAA;AA+CViB,UAAAA,GAAG,GAAG9B,OAAO,CAAC4B,SAAR,CAAkBC,QAAlB,EAA4BnB,OAAO,CAACS,gBAApC,CAAN;AACA,cAAIQ,SAAJ,EAAeG,GAAG,mCAAQH,SAAR,GAAsBG,GAAtB,CAAH;AAhDL;AAAA,sCAiDJ1B,cAAc,CAACC,MAAD,EAASY,MAAM,CAACd,IAAhB,CAjDV;;AAAA;AAAA;;AAAA;AAqDZ,cAAImB,WAAJ,EAAiB;AACfL,YAAAA,MAAM,CAACc,IAAP,GAAcT,WAAd;AACAA,YAAAA,WAAW,GAAG,IAAd;AACD;;AAED,cAAIG,eAAJ,EAAqB;AACnBR,YAAAA,MAAM,CAACe,QAAP,GAAkBP,eAAlB;AACAA,YAAAA,eAAe,GAAG,IAAlB;AACD;;AAED,cAAIK,GAAJ,EAAS;AACP,gBAAIA,GAAG,CAACG,IAAR,EAAchB,MAAM,CAACc,IAAP,GAAcD,GAAG,CAACG,IAAlB;AACd,gBAAIH,GAAG,CAACI,QAAR,EAAkBjB,MAAM,CAACe,QAAP,GAAkBF,GAAG,CAACI,QAAtB;AAClB,gBAAIJ,GAAG,CAAC3B,IAAR,EAAcc,MAAM,CAACd,IAAP,GAAcgC,QAAQ,CAACL,GAAG,CAAC3B,IAAL,EAAW,EAAX,CAAtB;AACdc,YAAAA,MAAM,CAACa,GAAP,GAAaA,GAAb;AACAA,YAAAA,GAAG,GAAG,IAAN;AACD;;AArEW,gBAuER,CAACb,MAAM,CAACd,IAAR,IAAgBc,MAAM,CAACG,IAAP,KAAgB,WAvExB;AAAA;AAAA;AAAA;;AAAA;AAwEV,iBAAM;AAAEH,YAAAA,MAAF;AAAUmB,YAAAA,IAAI,EAAE,2DAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,aAAD;AAAhB,WAAN;;AAxEU;AAAA;;AAAA;AA4ERC,UAAAA,cA5EQ,GA4ESpB,MAAM,CAACd,IA5EhB;AA6ENmC,UAAAA,YA7EM,GA6ESxC,KAAK,EA7Ed,EA+EZ;AACA;AACA;;AAjFY;AAAA,sCAkFaO,MAAM,CAACkC,OAAP,CAAeC,IAAI,CAACC,GAAL,CAASJ,cAAT,EAAyB3B,OAAO,CAACC,aAAjC,CAAf,CAlFb;;AAAA;AAkFN+B,UAAAA,UAlFM;AAmFZL,UAAAA,cAAc,IAAIK,UAAU,CAAC5B,KAAX,CAAiB6B,MAAnC;AAEA,cAAI,CAACN,cAAL,EAAqBC,YAAY,CAACM,OAAb;AAEfR,UAAAA,IAvFM,GAuFC,2DAAC;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAEV,yBAAMM,UAAU,CAAC5B,KAAjB;;AAFU;AAAA,uBAIHuB,cAJG;AAAA;AAAA;AAAA;;AAAA;AAAA,8CAKsBhC,MAAM,CAACkC,OAAP,CAAeF,cAAf,CALtB;;AAAA;AAAA;AAKAxB,kBAAAA,IALA,0BAKAA,IALA;AAKMC,kBAAAA,KALN,0BAKMA,KALN;;AAAA,uBAMJD,IANI;AAAA;AAAA;AAAA;;AAONwB,kBAAAA,cAAc,GAAG,CAAjB;AAPM;;AAAA;AAURA,kBAAAA,cAAc,IAAIvB,KAAK,CAAC6B,MAAxB;AAVQ;AAWR,yBAAM7B,KAAN;;AAXQ;AAAA;AAAA;;AAAA;AAAA;AAcVwB,kBAAAA,YAAY,CAACM,OAAb;AAdU;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,WAAD,IAvFD;AAAA;AAyGZ,iBAAM;AAAE3B,YAAAA,MAAF;AAAUmB,YAAAA;AAAV,WAAN;;AAzGY;AAAA;AAAA,sCA4GNE,YAAY,CAACO,OA5GP;;AAAA;AAAA,eA+GRR,cA/GQ;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA,qCAgHYD,IAhHZ;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAgHOU,UAAAA,CAhHP;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA,sCAmHN1C,cAAc,CAACC,MAAD,EAASY,MAAM,CAACd,IAAhB,CAnHR;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA,sCAsHRE,MAAM,CAAC0C,MAAP,EAtHQ;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAAD,IAAjB;AAyHD,CA7HD","sourcesContent":["const defer = require('p-defer')\nconst Headers = require('./extract-headers')\nconst LteReader = require('./lte-reader')\n\nfunction getPadding (size) {\n  size &= 511\n  return size && 512 - size\n}\n\nasync function discardPadding (reader, size) {\n  const overflow = getPadding(size)\n  if (overflow) await reader.next(overflow)\n}\n\nmodule.exports = options => {\n  options = options || {}\n  options.highWaterMark = options.highWaterMark || 1024 * 16\n\n  return source => (async function * () {\n    const reader = LteReader(source)\n    let gnuLongPath, gnuLongLinkPath, paxGlobal, pax\n\n    try {\n      while (true) {\n        let headerBytes\n        try {\n          const { done, value } = await reader.next(512)\n          if (done) return\n          headerBytes = value\n        } catch (err) {\n          // Is ok, this is the end of the stream!\n          if (err.code === 'ERR_UNDER_READ') return\n          throw err\n        }\n\n        const header = Headers.decode(headerBytes, options.filenameEncoding)\n        if (!header) continue\n\n        if (header.type === 'gnu-long-path') {\n          const { done, value: gnuLongPathBytes } = await reader.next(header.size)\n          if (done) return\n          gnuLongPath = Headers.decodeLongPath(gnuLongPathBytes, options.filenameEncoding)\n          await discardPadding(reader, header.size)\n          continue\n        }\n\n        if (header.type === 'gnu-long-link-path') {\n          const { done, value: gnuLongLinkPathBytes } = await reader.next(header.size)\n          if (done) return\n          gnuLongLinkPath = Headers.decodeLongPath(gnuLongLinkPathBytes, options.filenameEncoding)\n          await discardPadding(reader, header.size)\n          continue\n        }\n\n        if (header.type === 'pax-global-header') {\n          const { done, value: paxGlobalBytes } = await reader.next(header.size)\n          if (done) return\n          paxGlobal = Headers.decodePax(paxGlobalBytes, options.filenameEncoding)\n          await discardPadding(reader, header.size)\n          continue\n        }\n\n        if (header.type === 'pax-header') {\n          const { done, value: paxBytes } = await reader.next(header.size)\n          if (done) return\n          pax = Headers.decodePax(paxBytes, options.filenameEncoding)\n          if (paxGlobal) pax = { ...paxGlobal, ...pax }\n          await discardPadding(reader, header.size)\n          continue\n        }\n\n        if (gnuLongPath) {\n          header.name = gnuLongPath\n          gnuLongPath = null\n        }\n\n        if (gnuLongLinkPath) {\n          header.linkname = gnuLongLinkPath\n          gnuLongLinkPath = null\n        }\n\n        if (pax) {\n          if (pax.path) header.name = pax.path\n          if (pax.linkpath) header.linkname = pax.linkpath\n          if (pax.size) header.size = parseInt(pax.size, 10)\n          header.pax = pax\n          pax = null\n        }\n\n        if (!header.size || header.type === 'directory') {\n          yield { header, body: (async function * () {})() }\n          continue\n        }\n\n        let bytesRemaining = header.size\n        const bodyConsumed = defer()\n\n        // Prefetch the first chunk.\n        // This allows us to stream entries for small files from the tar without\n        // explicitly streaming the body of each.\n        const firstChunk = await reader.nextLte(Math.min(bytesRemaining, options.highWaterMark))\n        bytesRemaining -= firstChunk.value.length\n\n        if (!bytesRemaining) bodyConsumed.resolve()\n\n        const body = (async function * () {\n          try {\n            yield firstChunk.value\n\n            while (bytesRemaining) {\n              const { done, value } = await reader.nextLte(bytesRemaining)\n              if (done) {\n                bytesRemaining = 0\n                return\n              }\n              bytesRemaining -= value.length\n              yield value\n            }\n          } finally {\n            bodyConsumed.resolve()\n          }\n        })()\n\n        yield { header, body }\n\n        // Wait for the body to be consumed\n        await bodyConsumed.promise\n\n        // Incase the body was not consumed entirely...\n        if (bytesRemaining) {\n          for await (const _ of body) {} // eslint-disable-line no-unused-vars\n        }\n\n        await discardPadding(reader, header.size)\n      }\n    } finally {\n      await reader.return()\n    }\n  })()\n}\n"]},"metadata":{},"sourceType":"script"}