{"ast":null,"code":"'use strict';\n\nconst CID = require('cids');\n\nconst withIs = require('class-is');\n\nconst uint8ArrayFromString = require('uint8arrays/from-string'); // Link represents an IPFS Merkle DAG Link between Nodes.\n\n\nclass DAGLink {\n  constructor(name, size, cid) {\n    if (!cid) {\n      throw new Error('A link requires a cid to point to');\n    } // assert(size, 'A link requires a size')\n    //  note - links should include size, but this assert is disabled\n    //  for now to maintain consistency with go-ipfs pinset\n\n\n    Object.defineProperties(this, {\n      Name: {\n        value: name || '',\n        writable: false,\n        enumerable: true\n      },\n      Tsize: {\n        value: size,\n        writable: false,\n        enumerable: true\n      },\n      Hash: {\n        value: new CID(cid),\n        writable: false,\n        enumerable: true\n      },\n      _nameBuf: {\n        value: null,\n        writable: true,\n        enumerable: false\n      }\n    });\n  }\n\n  toString() {\n    return \"DAGLink <\".concat(this.Hash.toBaseEncodedString(), \" - name: \\\"\").concat(this.Name, \"\\\", size: \").concat(this.Tsize, \">\");\n  }\n\n  toJSON() {\n    if (!this._json) {\n      this._json = Object.freeze({\n        name: this.Name,\n        size: this.Tsize,\n        cid: this.Hash.toBaseEncodedString()\n      });\n    }\n\n    return Object.assign({}, this._json);\n  } // Memoize the Uint8Array representation of name\n  // We need this to sort the links, otherwise\n  // we will reallocate new Uint8Arrays every time\n\n\n  get nameAsBuffer() {\n    if (this._nameBuf !== null) {\n      return this._nameBuf;\n    }\n\n    this._nameBuf = uint8ArrayFromString(this.Name);\n    return this._nameBuf;\n  }\n\n}\n\nexports = module.exports = withIs(DAGLink, {\n  className: 'DAGLink',\n  symbolName: '@ipld/js-ipld-dag-pb/daglink'\n});","map":{"version":3,"sources":["C:/Users/SAINIK/Desktop/LEARNING BTC/NFT-Auction-Marketplace/node_modules/ipld-dag-pb/src/dag-link/dagLink.js"],"names":["CID","require","withIs","uint8ArrayFromString","DAGLink","constructor","name","size","cid","Error","Object","defineProperties","Name","value","writable","enumerable","Tsize","Hash","_nameBuf","toString","toBaseEncodedString","toJSON","_json","freeze","assign","nameAsBuffer","exports","module","className","symbolName"],"mappings":"AAAA;;AAEA,MAAMA,GAAG,GAAGC,OAAO,CAAC,MAAD,CAAnB;;AACA,MAAMC,MAAM,GAAGD,OAAO,CAAC,UAAD,CAAtB;;AACA,MAAME,oBAAoB,GAAGF,OAAO,CAAC,yBAAD,CAApC,C,CAEA;;;AACA,MAAMG,OAAN,CAAc;AACZC,EAAAA,WAAW,CAAEC,IAAF,EAAQC,IAAR,EAAcC,GAAd,EAAmB;AAC5B,QAAI,CAACA,GAAL,EAAU;AACR,YAAM,IAAIC,KAAJ,CAAU,mCAAV,CAAN;AACD,KAH2B,CAK5B;AACA;AACA;;;AAEAC,IAAAA,MAAM,CAACC,gBAAP,CAAwB,IAAxB,EAA8B;AAC5BC,MAAAA,IAAI,EAAE;AAAEC,QAAAA,KAAK,EAAEP,IAAI,IAAI,EAAjB;AAAqBQ,QAAAA,QAAQ,EAAE,KAA/B;AAAsCC,QAAAA,UAAU,EAAE;AAAlD,OADsB;AAE5BC,MAAAA,KAAK,EAAE;AAAEH,QAAAA,KAAK,EAAEN,IAAT;AAAeO,QAAAA,QAAQ,EAAE,KAAzB;AAAgCC,QAAAA,UAAU,EAAE;AAA5C,OAFqB;AAG5BE,MAAAA,IAAI,EAAE;AAAEJ,QAAAA,KAAK,EAAE,IAAIb,GAAJ,CAAQQ,GAAR,CAAT;AAAuBM,QAAAA,QAAQ,EAAE,KAAjC;AAAwCC,QAAAA,UAAU,EAAE;AAApD,OAHsB;AAI5BG,MAAAA,QAAQ,EAAE;AAAEL,QAAAA,KAAK,EAAE,IAAT;AAAeC,QAAAA,QAAQ,EAAE,IAAzB;AAA+BC,QAAAA,UAAU,EAAE;AAA3C;AAJkB,KAA9B;AAMD;;AAEDI,EAAAA,QAAQ,GAAI;AACV,8BAAmB,KAAKF,IAAL,CAAUG,mBAAV,EAAnB,wBAA+D,KAAKR,IAApE,uBAAoF,KAAKI,KAAzF;AACD;;AAEDK,EAAAA,MAAM,GAAI;AACR,QAAI,CAAC,KAAKC,KAAV,EAAiB;AACf,WAAKA,KAAL,GAAaZ,MAAM,CAACa,MAAP,CAAc;AACzBjB,QAAAA,IAAI,EAAE,KAAKM,IADc;AAEzBL,QAAAA,IAAI,EAAE,KAAKS,KAFc;AAGzBR,QAAAA,GAAG,EAAE,KAAKS,IAAL,CAAUG,mBAAV;AAHoB,OAAd,CAAb;AAKD;;AAED,WAAOV,MAAM,CAACc,MAAP,CAAc,EAAd,EAAkB,KAAKF,KAAvB,CAAP;AACD,GAhCW,CAkCZ;AACA;AACA;;;AACgB,MAAZG,YAAY,GAAI;AAClB,QAAI,KAAKP,QAAL,KAAkB,IAAtB,EAA4B;AAC1B,aAAO,KAAKA,QAAZ;AACD;;AAED,SAAKA,QAAL,GAAgBf,oBAAoB,CAAC,KAAKS,IAAN,CAApC;AACA,WAAO,KAAKM,QAAZ;AACD;;AA5CW;;AA+CdQ,OAAO,GAAGC,MAAM,CAACD,OAAP,GAAiBxB,MAAM,CAACE,OAAD,EAAU;AAAEwB,EAAAA,SAAS,EAAE,SAAb;AAAwBC,EAAAA,UAAU,EAAE;AAApC,CAAV,CAAjC","sourcesContent":["'use strict'\n\nconst CID = require('cids')\nconst withIs = require('class-is')\nconst uint8ArrayFromString = require('uint8arrays/from-string')\n\n// Link represents an IPFS Merkle DAG Link between Nodes.\nclass DAGLink {\n  constructor (name, size, cid) {\n    if (!cid) {\n      throw new Error('A link requires a cid to point to')\n    }\n\n    // assert(size, 'A link requires a size')\n    //  note - links should include size, but this assert is disabled\n    //  for now to maintain consistency with go-ipfs pinset\n\n    Object.defineProperties(this, {\n      Name: { value: name || '', writable: false, enumerable: true },\n      Tsize: { value: size, writable: false, enumerable: true },\n      Hash: { value: new CID(cid), writable: false, enumerable: true },\n      _nameBuf: { value: null, writable: true, enumerable: false }\n    })\n  }\n\n  toString () {\n    return `DAGLink <${this.Hash.toBaseEncodedString()} - name: \"${this.Name}\", size: ${this.Tsize}>`\n  }\n\n  toJSON () {\n    if (!this._json) {\n      this._json = Object.freeze({\n        name: this.Name,\n        size: this.Tsize,\n        cid: this.Hash.toBaseEncodedString()\n      })\n    }\n\n    return Object.assign({}, this._json)\n  }\n\n  // Memoize the Uint8Array representation of name\n  // We need this to sort the links, otherwise\n  // we will reallocate new Uint8Arrays every time\n  get nameAsBuffer () {\n    if (this._nameBuf !== null) {\n      return this._nameBuf\n    }\n\n    this._nameBuf = uint8ArrayFromString(this.Name)\n    return this._nameBuf\n  }\n}\n\nexports = module.exports = withIs(DAGLink, { className: 'DAGLink', symbolName: '@ipld/js-ipld-dag-pb/daglink' })\n"]},"metadata":{},"sourceType":"script"}