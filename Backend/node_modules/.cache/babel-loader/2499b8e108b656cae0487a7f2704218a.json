{"ast":null,"code":"'use strict';\n/* globals Symbol: false, Uint8Array: false, WeakMap: false */\n\n/*!\n * deep-eql\n * Copyright(c) 2013 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\nvar type = require('type-detect');\n\nfunction FakeMap() {\n  this._key = 'chai/deep-eql__' + Math.random() + Date.now();\n}\n\nFakeMap.prototype = {\n  get: function getMap(key) {\n    return key[this._key];\n  },\n  set: function setMap(key, value) {\n    if (Object.isExtensible(key)) {\n      Object.defineProperty(key, this._key, {\n        value: value,\n        configurable: true\n      });\n    }\n  }\n};\nvar MemoizeMap = typeof WeakMap === 'function' ? WeakMap : FakeMap;\n/*!\n * Check to see if the MemoizeMap has recorded a result of the two operands\n *\n * @param {Mixed} leftHandOperand\n * @param {Mixed} rightHandOperand\n * @param {MemoizeMap} memoizeMap\n * @returns {Boolean|null} result\n*/\n\nfunction memoizeCompare(leftHandOperand, rightHandOperand, memoizeMap) {\n  // Technically, WeakMap keys can *only* be objects, not primitives.\n  if (!memoizeMap || isPrimitive(leftHandOperand) || isPrimitive(rightHandOperand)) {\n    return null;\n  }\n\n  var leftHandMap = memoizeMap.get(leftHandOperand);\n\n  if (leftHandMap) {\n    var result = leftHandMap.get(rightHandOperand);\n\n    if (typeof result === 'boolean') {\n      return result;\n    }\n  }\n\n  return null;\n}\n/*!\n * Set the result of the equality into the MemoizeMap\n *\n * @param {Mixed} leftHandOperand\n * @param {Mixed} rightHandOperand\n * @param {MemoizeMap} memoizeMap\n * @param {Boolean} result\n*/\n\n\nfunction memoizeSet(leftHandOperand, rightHandOperand, memoizeMap, result) {\n  // Technically, WeakMap keys can *only* be objects, not primitives.\n  if (!memoizeMap || isPrimitive(leftHandOperand) || isPrimitive(rightHandOperand)) {\n    return;\n  }\n\n  var leftHandMap = memoizeMap.get(leftHandOperand);\n\n  if (leftHandMap) {\n    leftHandMap.set(rightHandOperand, result);\n  } else {\n    leftHandMap = new MemoizeMap();\n    leftHandMap.set(rightHandOperand, result);\n    memoizeMap.set(leftHandOperand, leftHandMap);\n  }\n}\n/*!\n * Primary Export\n */\n\n\nmodule.exports = deepEqual;\nmodule.exports.MemoizeMap = MemoizeMap;\n/**\n * Assert deeply nested sameValue equality between two objects of any type.\n *\n * @param {Mixed} leftHandOperand\n * @param {Mixed} rightHandOperand\n * @param {Object} [options] (optional) Additional options\n * @param {Array} [options.comparator] (optional) Override default algorithm, determining custom equality.\n * @param {Array} [options.memoize] (optional) Provide a custom memoization object which will cache the results of\n    complex objects for a speed boost. By passing `false` you can disable memoization, but this will cause circular\n    references to blow the stack.\n * @return {Boolean} equal match\n */\n\nfunction deepEqual(leftHandOperand, rightHandOperand, options) {\n  // If we have a comparator, we can't assume anything; so bail to its check first.\n  if (options && options.comparator) {\n    return extensiveDeepEqual(leftHandOperand, rightHandOperand, options);\n  }\n\n  var simpleResult = simpleEqual(leftHandOperand, rightHandOperand);\n\n  if (simpleResult !== null) {\n    return simpleResult;\n  } // Deeper comparisons are pushed through to a larger function\n\n\n  return extensiveDeepEqual(leftHandOperand, rightHandOperand, options);\n}\n/**\n * Many comparisons can be canceled out early via simple equality or primitive checks.\n * @param {Mixed} leftHandOperand\n * @param {Mixed} rightHandOperand\n * @return {Boolean|null} equal match\n */\n\n\nfunction simpleEqual(leftHandOperand, rightHandOperand) {\n  // Equal references (except for Numbers) can be returned early\n  if (leftHandOperand === rightHandOperand) {\n    // Handle +-0 cases\n    return leftHandOperand !== 0 || 1 / leftHandOperand === 1 / rightHandOperand;\n  } // handle NaN cases\n\n\n  if (leftHandOperand !== leftHandOperand && // eslint-disable-line no-self-compare\n  rightHandOperand !== rightHandOperand // eslint-disable-line no-self-compare\n  ) {\n      return true;\n    } // Anything that is not an 'object', i.e. symbols, functions, booleans, numbers,\n  // strings, and undefined, can be compared by reference.\n\n\n  if (isPrimitive(leftHandOperand) || isPrimitive(rightHandOperand)) {\n    // Easy out b/c it would have passed the first equality check\n    return false;\n  }\n\n  return null;\n}\n/*!\n * The main logic of the `deepEqual` function.\n *\n * @param {Mixed} leftHandOperand\n * @param {Mixed} rightHandOperand\n * @param {Object} [options] (optional) Additional options\n * @param {Array} [options.comparator] (optional) Override default algorithm, determining custom equality.\n * @param {Array} [options.memoize] (optional) Provide a custom memoization object which will cache the results of\n    complex objects for a speed boost. By passing `false` you can disable memoization, but this will cause circular\n    references to blow the stack.\n * @return {Boolean} equal match\n*/\n\n\nfunction extensiveDeepEqual(leftHandOperand, rightHandOperand, options) {\n  options = options || {};\n  options.memoize = options.memoize === false ? false : options.memoize || new MemoizeMap();\n  var comparator = options && options.comparator; // Check if a memoized result exists.\n\n  var memoizeResultLeft = memoizeCompare(leftHandOperand, rightHandOperand, options.memoize);\n\n  if (memoizeResultLeft !== null) {\n    return memoizeResultLeft;\n  }\n\n  var memoizeResultRight = memoizeCompare(rightHandOperand, leftHandOperand, options.memoize);\n\n  if (memoizeResultRight !== null) {\n    return memoizeResultRight;\n  } // If a comparator is present, use it.\n\n\n  if (comparator) {\n    var comparatorResult = comparator(leftHandOperand, rightHandOperand); // Comparators may return null, in which case we want to go back to default behavior.\n\n    if (comparatorResult === false || comparatorResult === true) {\n      memoizeSet(leftHandOperand, rightHandOperand, options.memoize, comparatorResult);\n      return comparatorResult;\n    } // To allow comparators to override *any* behavior, we ran them first. Since it didn't decide\n    // what to do, we need to make sure to return the basic tests first before we move on.\n\n\n    var simpleResult = simpleEqual(leftHandOperand, rightHandOperand);\n\n    if (simpleResult !== null) {\n      // Don't memoize this, it takes longer to set/retrieve than to just compare.\n      return simpleResult;\n    }\n  }\n\n  var leftHandType = type(leftHandOperand);\n\n  if (leftHandType !== type(rightHandOperand)) {\n    memoizeSet(leftHandOperand, rightHandOperand, options.memoize, false);\n    return false;\n  } // Temporarily set the operands in the memoize object to prevent blowing the stack\n\n\n  memoizeSet(leftHandOperand, rightHandOperand, options.memoize, true);\n  var result = extensiveDeepEqualByType(leftHandOperand, rightHandOperand, leftHandType, options);\n  memoizeSet(leftHandOperand, rightHandOperand, options.memoize, result);\n  return result;\n}\n\nfunction extensiveDeepEqualByType(leftHandOperand, rightHandOperand, leftHandType, options) {\n  switch (leftHandType) {\n    case 'String':\n    case 'Number':\n    case 'Boolean':\n    case 'Date':\n      // If these types are their instance types (e.g. `new Number`) then re-deepEqual against their values\n      return deepEqual(leftHandOperand.valueOf(), rightHandOperand.valueOf());\n\n    case 'Promise':\n    case 'Symbol':\n    case 'function':\n    case 'WeakMap':\n    case 'WeakSet':\n    case 'Error':\n      return leftHandOperand === rightHandOperand;\n\n    case 'Arguments':\n    case 'Int8Array':\n    case 'Uint8Array':\n    case 'Uint8ClampedArray':\n    case 'Int16Array':\n    case 'Uint16Array':\n    case 'Int32Array':\n    case 'Uint32Array':\n    case 'Float32Array':\n    case 'Float64Array':\n    case 'Array':\n      return iterableEqual(leftHandOperand, rightHandOperand, options);\n\n    case 'RegExp':\n      return regexpEqual(leftHandOperand, rightHandOperand);\n\n    case 'Generator':\n      return generatorEqual(leftHandOperand, rightHandOperand, options);\n\n    case 'DataView':\n      return iterableEqual(new Uint8Array(leftHandOperand.buffer), new Uint8Array(rightHandOperand.buffer), options);\n\n    case 'ArrayBuffer':\n      return iterableEqual(new Uint8Array(leftHandOperand), new Uint8Array(rightHandOperand), options);\n\n    case 'Set':\n      return entriesEqual(leftHandOperand, rightHandOperand, options);\n\n    case 'Map':\n      return entriesEqual(leftHandOperand, rightHandOperand, options);\n\n    default:\n      return objectEqual(leftHandOperand, rightHandOperand, options);\n  }\n}\n/*!\n * Compare two Regular Expressions for equality.\n *\n * @param {RegExp} leftHandOperand\n * @param {RegExp} rightHandOperand\n * @return {Boolean} result\n */\n\n\nfunction regexpEqual(leftHandOperand, rightHandOperand) {\n  return leftHandOperand.toString() === rightHandOperand.toString();\n}\n/*!\n * Compare two Sets/Maps for equality. Faster than other equality functions.\n *\n * @param {Set} leftHandOperand\n * @param {Set} rightHandOperand\n * @param {Object} [options] (Optional)\n * @return {Boolean} result\n */\n\n\nfunction entriesEqual(leftHandOperand, rightHandOperand, options) {\n  // IE11 doesn't support Set#entries or Set#@@iterator, so we need manually populate using Set#forEach\n  if (leftHandOperand.size !== rightHandOperand.size) {\n    return false;\n  }\n\n  if (leftHandOperand.size === 0) {\n    return true;\n  }\n\n  var leftHandItems = [];\n  var rightHandItems = [];\n  leftHandOperand.forEach(function gatherEntries(key, value) {\n    leftHandItems.push([key, value]);\n  });\n  rightHandOperand.forEach(function gatherEntries(key, value) {\n    rightHandItems.push([key, value]);\n  });\n  return iterableEqual(leftHandItems.sort(), rightHandItems.sort(), options);\n}\n/*!\n * Simple equality for flat iterable objects such as Arrays, TypedArrays or Node.js buffers.\n *\n * @param {Iterable} leftHandOperand\n * @param {Iterable} rightHandOperand\n * @param {Object} [options] (Optional)\n * @return {Boolean} result\n */\n\n\nfunction iterableEqual(leftHandOperand, rightHandOperand, options) {\n  var length = leftHandOperand.length;\n\n  if (length !== rightHandOperand.length) {\n    return false;\n  }\n\n  if (length === 0) {\n    return true;\n  }\n\n  var index = -1;\n\n  while (++index < length) {\n    if (deepEqual(leftHandOperand[index], rightHandOperand[index], options) === false) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/*!\n * Simple equality for generator objects such as those returned by generator functions.\n *\n * @param {Iterable} leftHandOperand\n * @param {Iterable} rightHandOperand\n * @param {Object} [options] (Optional)\n * @return {Boolean} result\n */\n\n\nfunction generatorEqual(leftHandOperand, rightHandOperand, options) {\n  return iterableEqual(getGeneratorEntries(leftHandOperand), getGeneratorEntries(rightHandOperand), options);\n}\n/*!\n * Determine if the given object has an @@iterator function.\n *\n * @param {Object} target\n * @return {Boolean} `true` if the object has an @@iterator function.\n */\n\n\nfunction hasIteratorFunction(target) {\n  return typeof Symbol !== 'undefined' && typeof target === 'object' && typeof Symbol.iterator !== 'undefined' && typeof target[Symbol.iterator] === 'function';\n}\n/*!\n * Gets all iterator entries from the given Object. If the Object has no @@iterator function, returns an empty array.\n * This will consume the iterator - which could have side effects depending on the @@iterator implementation.\n *\n * @param {Object} target\n * @returns {Array} an array of entries from the @@iterator function\n */\n\n\nfunction getIteratorEntries(target) {\n  if (hasIteratorFunction(target)) {\n    try {\n      return getGeneratorEntries(target[Symbol.iterator]());\n    } catch (iteratorError) {\n      return [];\n    }\n  }\n\n  return [];\n}\n/*!\n * Gets all entries from a Generator. This will consume the generator - which could have side effects.\n *\n * @param {Generator} target\n * @returns {Array} an array of entries from the Generator.\n */\n\n\nfunction getGeneratorEntries(generator) {\n  var generatorResult = generator.next();\n  var accumulator = [generatorResult.value];\n\n  while (generatorResult.done === false) {\n    generatorResult = generator.next();\n    accumulator.push(generatorResult.value);\n  }\n\n  return accumulator;\n}\n/*!\n * Gets all own and inherited enumerable keys from a target.\n *\n * @param {Object} target\n * @returns {Array} an array of own and inherited enumerable keys from the target.\n */\n\n\nfunction getEnumerableKeys(target) {\n  var keys = [];\n\n  for (var key in target) {\n    keys.push(key);\n  }\n\n  return keys;\n}\n/*!\n * Determines if two objects have matching values, given a set of keys. Defers to deepEqual for the equality check of\n * each key. If any value of the given key is not equal, the function will return false (early).\n *\n * @param {Mixed} leftHandOperand\n * @param {Mixed} rightHandOperand\n * @param {Array} keys An array of keys to compare the values of leftHandOperand and rightHandOperand against\n * @param {Object} [options] (Optional)\n * @return {Boolean} result\n */\n\n\nfunction keysEqual(leftHandOperand, rightHandOperand, keys, options) {\n  var length = keys.length;\n\n  if (length === 0) {\n    return true;\n  }\n\n  for (var i = 0; i < length; i += 1) {\n    if (deepEqual(leftHandOperand[keys[i]], rightHandOperand[keys[i]], options) === false) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/*!\n * Recursively check the equality of two Objects. Once basic sameness has been established it will defer to `deepEqual`\n * for each enumerable key in the object.\n *\n * @param {Mixed} leftHandOperand\n * @param {Mixed} rightHandOperand\n * @param {Object} [options] (Optional)\n * @return {Boolean} result\n */\n\n\nfunction objectEqual(leftHandOperand, rightHandOperand, options) {\n  var leftHandKeys = getEnumerableKeys(leftHandOperand);\n  var rightHandKeys = getEnumerableKeys(rightHandOperand);\n\n  if (leftHandKeys.length && leftHandKeys.length === rightHandKeys.length) {\n    leftHandKeys.sort();\n    rightHandKeys.sort();\n\n    if (iterableEqual(leftHandKeys, rightHandKeys) === false) {\n      return false;\n    }\n\n    return keysEqual(leftHandOperand, rightHandOperand, leftHandKeys, options);\n  }\n\n  var leftHandEntries = getIteratorEntries(leftHandOperand);\n  var rightHandEntries = getIteratorEntries(rightHandOperand);\n\n  if (leftHandEntries.length && leftHandEntries.length === rightHandEntries.length) {\n    leftHandEntries.sort();\n    rightHandEntries.sort();\n    return iterableEqual(leftHandEntries, rightHandEntries, options);\n  }\n\n  if (leftHandKeys.length === 0 && leftHandEntries.length === 0 && rightHandKeys.length === 0 && rightHandEntries.length === 0) {\n    return true;\n  }\n\n  return false;\n}\n/*!\n * Returns true if the argument is a primitive.\n *\n * This intentionally returns true for all objects that can be compared by reference,\n * including functions and symbols.\n *\n * @param {Mixed} value\n * @return {Boolean} result\n */\n\n\nfunction isPrimitive(value) {\n  return value === null || typeof value !== 'object';\n}","map":{"version":3,"sources":["C:/Users/SAINIK/Desktop/LEARNING BTC/NFT-Auction-Marketplace/node_modules/deep-eql/index.js"],"names":["type","require","FakeMap","_key","Math","random","Date","now","prototype","get","getMap","key","set","setMap","value","Object","isExtensible","defineProperty","configurable","MemoizeMap","WeakMap","memoizeCompare","leftHandOperand","rightHandOperand","memoizeMap","isPrimitive","leftHandMap","result","memoizeSet","module","exports","deepEqual","options","comparator","extensiveDeepEqual","simpleResult","simpleEqual","memoize","memoizeResultLeft","memoizeResultRight","comparatorResult","leftHandType","extensiveDeepEqualByType","valueOf","iterableEqual","regexpEqual","generatorEqual","Uint8Array","buffer","entriesEqual","objectEqual","toString","size","leftHandItems","rightHandItems","forEach","gatherEntries","push","sort","length","index","getGeneratorEntries","hasIteratorFunction","target","Symbol","iterator","getIteratorEntries","iteratorError","generator","generatorResult","next","accumulator","done","getEnumerableKeys","keys","keysEqual","i","leftHandKeys","rightHandKeys","leftHandEntries","rightHandEntries"],"mappings":"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","sourcesContent":["'use strict';\n/* globals Symbol: false, Uint8Array: false, WeakMap: false */\n/*!\n * deep-eql\n * Copyright(c) 2013 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\nvar type = require('type-detect');\nfunction FakeMap() {\n  this._key = 'chai/deep-eql__' + Math.random() + Date.now();\n}\n\nFakeMap.prototype = {\n  get: function getMap(key) {\n    return key[this._key];\n  },\n  set: function setMap(key, value) {\n    if (Object.isExtensible(key)) {\n      Object.defineProperty(key, this._key, {\n        value: value,\n        configurable: true,\n      });\n    }\n  },\n};\n\nvar MemoizeMap = typeof WeakMap === 'function' ? WeakMap : FakeMap;\n/*!\n * Check to see if the MemoizeMap has recorded a result of the two operands\n *\n * @param {Mixed} leftHandOperand\n * @param {Mixed} rightHandOperand\n * @param {MemoizeMap} memoizeMap\n * @returns {Boolean|null} result\n*/\nfunction memoizeCompare(leftHandOperand, rightHandOperand, memoizeMap) {\n  // Technically, WeakMap keys can *only* be objects, not primitives.\n  if (!memoizeMap || isPrimitive(leftHandOperand) || isPrimitive(rightHandOperand)) {\n    return null;\n  }\n  var leftHandMap = memoizeMap.get(leftHandOperand);\n  if (leftHandMap) {\n    var result = leftHandMap.get(rightHandOperand);\n    if (typeof result === 'boolean') {\n      return result;\n    }\n  }\n  return null;\n}\n\n/*!\n * Set the result of the equality into the MemoizeMap\n *\n * @param {Mixed} leftHandOperand\n * @param {Mixed} rightHandOperand\n * @param {MemoizeMap} memoizeMap\n * @param {Boolean} result\n*/\nfunction memoizeSet(leftHandOperand, rightHandOperand, memoizeMap, result) {\n  // Technically, WeakMap keys can *only* be objects, not primitives.\n  if (!memoizeMap || isPrimitive(leftHandOperand) || isPrimitive(rightHandOperand)) {\n    return;\n  }\n  var leftHandMap = memoizeMap.get(leftHandOperand);\n  if (leftHandMap) {\n    leftHandMap.set(rightHandOperand, result);\n  } else {\n    leftHandMap = new MemoizeMap();\n    leftHandMap.set(rightHandOperand, result);\n    memoizeMap.set(leftHandOperand, leftHandMap);\n  }\n}\n\n/*!\n * Primary Export\n */\n\nmodule.exports = deepEqual;\nmodule.exports.MemoizeMap = MemoizeMap;\n\n/**\n * Assert deeply nested sameValue equality between two objects of any type.\n *\n * @param {Mixed} leftHandOperand\n * @param {Mixed} rightHandOperand\n * @param {Object} [options] (optional) Additional options\n * @param {Array} [options.comparator] (optional) Override default algorithm, determining custom equality.\n * @param {Array} [options.memoize] (optional) Provide a custom memoization object which will cache the results of\n    complex objects for a speed boost. By passing `false` you can disable memoization, but this will cause circular\n    references to blow the stack.\n * @return {Boolean} equal match\n */\nfunction deepEqual(leftHandOperand, rightHandOperand, options) {\n  // If we have a comparator, we can't assume anything; so bail to its check first.\n  if (options && options.comparator) {\n    return extensiveDeepEqual(leftHandOperand, rightHandOperand, options);\n  }\n\n  var simpleResult = simpleEqual(leftHandOperand, rightHandOperand);\n  if (simpleResult !== null) {\n    return simpleResult;\n  }\n\n  // Deeper comparisons are pushed through to a larger function\n  return extensiveDeepEqual(leftHandOperand, rightHandOperand, options);\n}\n\n/**\n * Many comparisons can be canceled out early via simple equality or primitive checks.\n * @param {Mixed} leftHandOperand\n * @param {Mixed} rightHandOperand\n * @return {Boolean|null} equal match\n */\nfunction simpleEqual(leftHandOperand, rightHandOperand) {\n  // Equal references (except for Numbers) can be returned early\n  if (leftHandOperand === rightHandOperand) {\n    // Handle +-0 cases\n    return leftHandOperand !== 0 || 1 / leftHandOperand === 1 / rightHandOperand;\n  }\n\n  // handle NaN cases\n  if (\n    leftHandOperand !== leftHandOperand && // eslint-disable-line no-self-compare\n    rightHandOperand !== rightHandOperand // eslint-disable-line no-self-compare\n  ) {\n    return true;\n  }\n\n  // Anything that is not an 'object', i.e. symbols, functions, booleans, numbers,\n  // strings, and undefined, can be compared by reference.\n  if (isPrimitive(leftHandOperand) || isPrimitive(rightHandOperand)) {\n    // Easy out b/c it would have passed the first equality check\n    return false;\n  }\n  return null;\n}\n\n/*!\n * The main logic of the `deepEqual` function.\n *\n * @param {Mixed} leftHandOperand\n * @param {Mixed} rightHandOperand\n * @param {Object} [options] (optional) Additional options\n * @param {Array} [options.comparator] (optional) Override default algorithm, determining custom equality.\n * @param {Array} [options.memoize] (optional) Provide a custom memoization object which will cache the results of\n    complex objects for a speed boost. By passing `false` you can disable memoization, but this will cause circular\n    references to blow the stack.\n * @return {Boolean} equal match\n*/\nfunction extensiveDeepEqual(leftHandOperand, rightHandOperand, options) {\n  options = options || {};\n  options.memoize = options.memoize === false ? false : options.memoize || new MemoizeMap();\n  var comparator = options && options.comparator;\n\n  // Check if a memoized result exists.\n  var memoizeResultLeft = memoizeCompare(leftHandOperand, rightHandOperand, options.memoize);\n  if (memoizeResultLeft !== null) {\n    return memoizeResultLeft;\n  }\n  var memoizeResultRight = memoizeCompare(rightHandOperand, leftHandOperand, options.memoize);\n  if (memoizeResultRight !== null) {\n    return memoizeResultRight;\n  }\n\n  // If a comparator is present, use it.\n  if (comparator) {\n    var comparatorResult = comparator(leftHandOperand, rightHandOperand);\n    // Comparators may return null, in which case we want to go back to default behavior.\n    if (comparatorResult === false || comparatorResult === true) {\n      memoizeSet(leftHandOperand, rightHandOperand, options.memoize, comparatorResult);\n      return comparatorResult;\n    }\n    // To allow comparators to override *any* behavior, we ran them first. Since it didn't decide\n    // what to do, we need to make sure to return the basic tests first before we move on.\n    var simpleResult = simpleEqual(leftHandOperand, rightHandOperand);\n    if (simpleResult !== null) {\n      // Don't memoize this, it takes longer to set/retrieve than to just compare.\n      return simpleResult;\n    }\n  }\n\n  var leftHandType = type(leftHandOperand);\n  if (leftHandType !== type(rightHandOperand)) {\n    memoizeSet(leftHandOperand, rightHandOperand, options.memoize, false);\n    return false;\n  }\n\n  // Temporarily set the operands in the memoize object to prevent blowing the stack\n  memoizeSet(leftHandOperand, rightHandOperand, options.memoize, true);\n\n  var result = extensiveDeepEqualByType(leftHandOperand, rightHandOperand, leftHandType, options);\n  memoizeSet(leftHandOperand, rightHandOperand, options.memoize, result);\n  return result;\n}\n\nfunction extensiveDeepEqualByType(leftHandOperand, rightHandOperand, leftHandType, options) {\n  switch (leftHandType) {\n    case 'String':\n    case 'Number':\n    case 'Boolean':\n    case 'Date':\n      // If these types are their instance types (e.g. `new Number`) then re-deepEqual against their values\n      return deepEqual(leftHandOperand.valueOf(), rightHandOperand.valueOf());\n    case 'Promise':\n    case 'Symbol':\n    case 'function':\n    case 'WeakMap':\n    case 'WeakSet':\n    case 'Error':\n      return leftHandOperand === rightHandOperand;\n    case 'Arguments':\n    case 'Int8Array':\n    case 'Uint8Array':\n    case 'Uint8ClampedArray':\n    case 'Int16Array':\n    case 'Uint16Array':\n    case 'Int32Array':\n    case 'Uint32Array':\n    case 'Float32Array':\n    case 'Float64Array':\n    case 'Array':\n      return iterableEqual(leftHandOperand, rightHandOperand, options);\n    case 'RegExp':\n      return regexpEqual(leftHandOperand, rightHandOperand);\n    case 'Generator':\n      return generatorEqual(leftHandOperand, rightHandOperand, options);\n    case 'DataView':\n      return iterableEqual(new Uint8Array(leftHandOperand.buffer), new Uint8Array(rightHandOperand.buffer), options);\n    case 'ArrayBuffer':\n      return iterableEqual(new Uint8Array(leftHandOperand), new Uint8Array(rightHandOperand), options);\n    case 'Set':\n      return entriesEqual(leftHandOperand, rightHandOperand, options);\n    case 'Map':\n      return entriesEqual(leftHandOperand, rightHandOperand, options);\n    default:\n      return objectEqual(leftHandOperand, rightHandOperand, options);\n  }\n}\n\n/*!\n * Compare two Regular Expressions for equality.\n *\n * @param {RegExp} leftHandOperand\n * @param {RegExp} rightHandOperand\n * @return {Boolean} result\n */\n\nfunction regexpEqual(leftHandOperand, rightHandOperand) {\n  return leftHandOperand.toString() === rightHandOperand.toString();\n}\n\n/*!\n * Compare two Sets/Maps for equality. Faster than other equality functions.\n *\n * @param {Set} leftHandOperand\n * @param {Set} rightHandOperand\n * @param {Object} [options] (Optional)\n * @return {Boolean} result\n */\n\nfunction entriesEqual(leftHandOperand, rightHandOperand, options) {\n  // IE11 doesn't support Set#entries or Set#@@iterator, so we need manually populate using Set#forEach\n  if (leftHandOperand.size !== rightHandOperand.size) {\n    return false;\n  }\n  if (leftHandOperand.size === 0) {\n    return true;\n  }\n  var leftHandItems = [];\n  var rightHandItems = [];\n  leftHandOperand.forEach(function gatherEntries(key, value) {\n    leftHandItems.push([ key, value ]);\n  });\n  rightHandOperand.forEach(function gatherEntries(key, value) {\n    rightHandItems.push([ key, value ]);\n  });\n  return iterableEqual(leftHandItems.sort(), rightHandItems.sort(), options);\n}\n\n/*!\n * Simple equality for flat iterable objects such as Arrays, TypedArrays or Node.js buffers.\n *\n * @param {Iterable} leftHandOperand\n * @param {Iterable} rightHandOperand\n * @param {Object} [options] (Optional)\n * @return {Boolean} result\n */\n\nfunction iterableEqual(leftHandOperand, rightHandOperand, options) {\n  var length = leftHandOperand.length;\n  if (length !== rightHandOperand.length) {\n    return false;\n  }\n  if (length === 0) {\n    return true;\n  }\n  var index = -1;\n  while (++index < length) {\n    if (deepEqual(leftHandOperand[index], rightHandOperand[index], options) === false) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/*!\n * Simple equality for generator objects such as those returned by generator functions.\n *\n * @param {Iterable} leftHandOperand\n * @param {Iterable} rightHandOperand\n * @param {Object} [options] (Optional)\n * @return {Boolean} result\n */\n\nfunction generatorEqual(leftHandOperand, rightHandOperand, options) {\n  return iterableEqual(getGeneratorEntries(leftHandOperand), getGeneratorEntries(rightHandOperand), options);\n}\n\n/*!\n * Determine if the given object has an @@iterator function.\n *\n * @param {Object} target\n * @return {Boolean} `true` if the object has an @@iterator function.\n */\nfunction hasIteratorFunction(target) {\n  return typeof Symbol !== 'undefined' &&\n    typeof target === 'object' &&\n    typeof Symbol.iterator !== 'undefined' &&\n    typeof target[Symbol.iterator] === 'function';\n}\n\n/*!\n * Gets all iterator entries from the given Object. If the Object has no @@iterator function, returns an empty array.\n * This will consume the iterator - which could have side effects depending on the @@iterator implementation.\n *\n * @param {Object} target\n * @returns {Array} an array of entries from the @@iterator function\n */\nfunction getIteratorEntries(target) {\n  if (hasIteratorFunction(target)) {\n    try {\n      return getGeneratorEntries(target[Symbol.iterator]());\n    } catch (iteratorError) {\n      return [];\n    }\n  }\n  return [];\n}\n\n/*!\n * Gets all entries from a Generator. This will consume the generator - which could have side effects.\n *\n * @param {Generator} target\n * @returns {Array} an array of entries from the Generator.\n */\nfunction getGeneratorEntries(generator) {\n  var generatorResult = generator.next();\n  var accumulator = [ generatorResult.value ];\n  while (generatorResult.done === false) {\n    generatorResult = generator.next();\n    accumulator.push(generatorResult.value);\n  }\n  return accumulator;\n}\n\n/*!\n * Gets all own and inherited enumerable keys from a target.\n *\n * @param {Object} target\n * @returns {Array} an array of own and inherited enumerable keys from the target.\n */\nfunction getEnumerableKeys(target) {\n  var keys = [];\n  for (var key in target) {\n    keys.push(key);\n  }\n  return keys;\n}\n\n/*!\n * Determines if two objects have matching values, given a set of keys. Defers to deepEqual for the equality check of\n * each key. If any value of the given key is not equal, the function will return false (early).\n *\n * @param {Mixed} leftHandOperand\n * @param {Mixed} rightHandOperand\n * @param {Array} keys An array of keys to compare the values of leftHandOperand and rightHandOperand against\n * @param {Object} [options] (Optional)\n * @return {Boolean} result\n */\nfunction keysEqual(leftHandOperand, rightHandOperand, keys, options) {\n  var length = keys.length;\n  if (length === 0) {\n    return true;\n  }\n  for (var i = 0; i < length; i += 1) {\n    if (deepEqual(leftHandOperand[keys[i]], rightHandOperand[keys[i]], options) === false) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/*!\n * Recursively check the equality of two Objects. Once basic sameness has been established it will defer to `deepEqual`\n * for each enumerable key in the object.\n *\n * @param {Mixed} leftHandOperand\n * @param {Mixed} rightHandOperand\n * @param {Object} [options] (Optional)\n * @return {Boolean} result\n */\n\nfunction objectEqual(leftHandOperand, rightHandOperand, options) {\n  var leftHandKeys = getEnumerableKeys(leftHandOperand);\n  var rightHandKeys = getEnumerableKeys(rightHandOperand);\n  if (leftHandKeys.length && leftHandKeys.length === rightHandKeys.length) {\n    leftHandKeys.sort();\n    rightHandKeys.sort();\n    if (iterableEqual(leftHandKeys, rightHandKeys) === false) {\n      return false;\n    }\n    return keysEqual(leftHandOperand, rightHandOperand, leftHandKeys, options);\n  }\n\n  var leftHandEntries = getIteratorEntries(leftHandOperand);\n  var rightHandEntries = getIteratorEntries(rightHandOperand);\n  if (leftHandEntries.length && leftHandEntries.length === rightHandEntries.length) {\n    leftHandEntries.sort();\n    rightHandEntries.sort();\n    return iterableEqual(leftHandEntries, rightHandEntries, options);\n  }\n\n  if (leftHandKeys.length === 0 &&\n      leftHandEntries.length === 0 &&\n      rightHandKeys.length === 0 &&\n      rightHandEntries.length === 0) {\n    return true;\n  }\n\n  return false;\n}\n\n/*!\n * Returns true if the argument is a primitive.\n *\n * This intentionally returns true for all objects that can be compared by reference,\n * including functions and symbols.\n *\n * @param {Mixed} value\n * @return {Boolean} result\n */\nfunction isPrimitive(value) {\n  return value === null || typeof value !== 'object';\n}\n"]},"metadata":{},"sourceType":"script"}